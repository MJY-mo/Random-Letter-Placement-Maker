<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ランダム文字配置メーカー</title>
    <link rel="icon" href="favicon11.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic&family=Dela+Gothic+One&family=DotGothic16&family=Hina+Mincho&family=Kaisei+Decol&family=Kaisei+Opti&family=Kiwi+Maru&family=Kosugi+Maru&family=M+PLUS+Rounded+1c:wght@400;700&family=Mochiy+Pop+One&family=Noto+Sans+JP:wght@400;700&family=Potta+One&family=RocknRoll+One&family=Sawarabi+Gothic&family=Shippori+Mincho&family=Yuji+Syuku&family=Yusei+Magic&family=Zen+Kaku+Gothic+New:wght@400;700&family=Klee+One&family=Stick&family=Rampart+One&family=Train+One&family=Zen+Maru+Gothic&family=Yomogi&display=swap" rel="stylesheet">
    <style>
        /* カスタムスタイル */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background-color: #f9fafb; /* bg-gray-50 */
            border-radius: 0 0 0.375rem 0.375rem; /* rounded-b-md */
        }
        .drop-area {
            border: 2px dashed #ccc;
            transition: border-color 0.3s, background-color 0.3s;
        }
        .drop-area.dragover {
            border-color: #4f46e5; /* indigo-600 */
            background-color: #e0e7ff; /* indigo-100 */
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .btn-gray.active-purple { background-color: #8b5cf6; /* violet-500 */ }
        .btn-gray.active-green { background-color: #22c55e; /* green-500 */ }
        
        /* カラーピッカーのスタイル */
        .color-picker-wrapper {
            position: relative;
            width: 36px;
            height: 36px;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 36px;
            height: 36px;
            padding: 0;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.375rem; /* rounded-md */
        }
        .color-picker-wrapper.is-disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .color-picker-wrapper.is-disabled input[type="color"] {
            cursor: not-allowed;
        }
        .color-picker-wrapper.is-disabled::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            width: 80%;
            height: 2px;
            background-color: rgba(220, 38, 38, 0.6); /* red-600 with opacity */
            transform: translateY(-50%) rotate(-45deg);
            pointer-events: none;
            border-radius: 1px;
        }

        /* キャンバスのカーソル */
        #main-canvas.draggable { cursor: grab; }
        #main-canvas.dragging { cursor: grabbing; }

        /* テキスト編集エリア */
        #text-editor-container {
            position: absolute;
            display: none;
            flex-direction: column;
            align-items: flex-start;
        }
        #text-editor {
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #4f46e5;
            outline: none;
            padding: 2px;
            box-sizing: border-box;
            line-height: 1.2; /* キャンバスの行間と合わせる */
        }
        #text-editor-buttons {
            margin-top: 4px;
        }
        #text-editor.vertical {
            writing-mode: vertical-rl;
            white-space: pre;
            resize: both; /* 縦横リサイズを有効化 */
            direction: ltr;
        }
        #text-editor.horizontal {
            resize: both;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen">

    <!-- 上部パネル -->
    <header class="bg-white shadow-md p-2 flex items-center justify-between flex-shrink-0">
        <h1 class="text-lg font-bold text-gray-700" data-lang="app-title">ランダム文字配置メーカー</h1>
        <div class="flex items-center space-x-2">
            <button id="btn-image-output" class="btn btn-gray bg-gray-500 text-white px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-image-output">画像出力</button>
            <button id="btn-help" class="btn btn-gray bg-gray-500 text-white px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-help">操作説明</button>
            <span class="text-gray-300">|</span>
            <button id="btn-save-settings" class="btn btn-gray bg-gray-500 text-white px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-save">保存</button>
            <button id="btn-load-settings" class="btn btn-gray bg-gray-500 text-white px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-load">呼出</button>
            <input type="file" id="settings-file-input" class="hidden" accept=".json">
            <span class="text-gray-300">|</span>
            <button id="btn-lang-switch" class="btn btn-gray bg-gray-500 text-white px-3 py-1.5 rounded-md text-sm font-semibold w-24">English</button>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <div class="flex-grow flex p-4 gap-4 overflow-hidden">

        <!-- 左パネル -->
        <div class="w-full md:w-1/3 max-w-lg flex-shrink-0 overflow-y-auto bg-white p-4 rounded-lg shadow-lg">
            
            <!-- 設定パネル (デフォルト) -->
            <div id="settings-panel">
                <div id="text-drop-area" class="drop-area w-full h-24 rounded-lg flex items-center justify-center text-center text-gray-500 mb-1 cursor-pointer p-2">
                    <span data-lang="text-drop-area">テキストファイル(.txt)をここにドロップ<br>またはクリックして選択</span>
                </div>
                <button id="delete-text-btn" class="text-xs text-red-500 hover:text-red-700 w-full text-right mb-2 hidden" data-lang="delete-text">テキストを削除</button>
                <input type="file" id="text-file-input" class="hidden" accept=".txt">
                <button id="generate-btn" class="btn bg-indigo-600 text-white w-full py-2 rounded-md font-bold hover:bg-indigo-700" data-lang="generate-btn">作成</button>
                
                <!-- アコーディオン -->
                <div class="space-y-2 mt-4">
                    <!-- フィールド設定 -->
                    <div>
                        <button class="accordion-toggle w-full text-left font-semibold p-2 bg-gray-200 rounded-md hover:bg-gray-300" data-target="#field-settings">
                            <span data-lang="accordion-field">フィールド設定</span>
                        </button>
                        <div id="field-settings" class="accordion-content">
                            <div class="p-4 space-y-3">
                                <div>
                                    <label class="block text-sm font-medium" data-lang="canvas-size">画面サイズ</label>
                                    <div class="flex gap-2 mt-1">
                                        <input type="number" id="canvas-width" value="800" class="w-full p-1 border rounded-md realtime-update save-state">
                                        <span class="self-center">x</span>
                                        <input type="number" id="canvas-height" value="600" class="w-full p-1 border rounded-md realtime-update save-state">
                                    </div>
                                </div>
                                <div class="setting-group">
                                    <label class="block text-sm font-medium" data-lang="bg-color">背景色</label>
                                    <div class="flex items-center justify-between gap-4">
                                        <input type="color" id="bg-color" value="#ffffff" class="w-24 h-8 border rounded-md realtime-update save-state">
                                        <label class="flex items-center text-sm flex-grow">
                                            <input type="checkbox" id="transparent-bg" class="mr-2 save-state" checked>
                                            <span data-lang="transparent-bg">背景を透過 (PNG出力時)</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                    <div id="bg-image-drop-area" class="drop-area w-full h-20 rounded-lg flex items-center justify-center text-center text-gray-500 mt-2 mb-1 cursor-pointer p-2">
                                        <span data-lang="bg-image-drop-area">背景画像をドロップ</span>
                                    </div>
                                    <button id="delete-bg-image-btn" class="text-xs text-red-500 hover:text-red-700 w-full text-right hidden" data-lang="delete-bg-image">背景画像を削除</button>
                                    <input type="file" id="bg-image-input" class="hidden" accept="image/*">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium" data-lang="bg-opacity">背景画像の透過度</label>
                                    <input type="range" id="bg-opacity" min="0" max="1" step="0.05" value="1" class="w-full mt-1 realtime-update save-state">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium" data-lang="bg-scale">背景画像の拡大縮小</label>
                                    <input type="range" id="bg-scale" min="0.1" max="3" step="0.1" value="1" class="w-full mt-1 realtime-update save-state">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ランダム処理の設定 -->
                    <div>
                        <button class="accordion-toggle w-full text-left font-semibold p-2 bg-gray-200 rounded-md hover:bg-gray-300" data-target="#random-settings">
                           <span data-lang="accordion-random">ランダム処理の設定</span>
                        </button>
                        <div id="random-settings" class="accordion-content">
                            <div class="p-4 space-y-4">
                                <div>
                                    <label class="block text-sm font-medium" data-lang="font-size">フォントサイズ (最小 - 最大)</label>
                                    <div class="flex gap-2 mt-1 items-center">
                                        <span id="font-size-min-val" class="text-xs w-8 text-center">16</span>
                                        <input type="range" id="font-size-min" min="8" max="150" value="16" class="w-full save-state">
                                        <input type="range" id="font-size-max" min="8" max="150" value="48" class="w-full save-state">
                                        <span id="font-size-max-val" class="text-xs w-8 text-center">48</span>
                                    </div>
                                </div>
                                <div class="setting-group">
                                    <label class="block text-sm font-medium" data-lang="text-opacity">文字の透過度</label>
                                    <div class="flex gap-4 text-sm mt-1">
                                        <label><input type="radio" name="text-opacity-mode" value="specify" checked class="save-state"> <span data-lang="mode-specify">指定</span></label>
                                        <label><input type="radio" name="text-opacity-mode" value="random" class="save-state"> <span data-lang="mode-random">ランダム</span></label>
                                    </div>
                                    <input type="range" id="text-opacity" min="0" max="1" step="0.05" value="1" class="w-full mt-1 save-state realtime-update">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium" data-lang="writing-mode">縦書きの比率</label>
                                    <input type="range" id="vertical-ratio" min="0" max="100" value="50" class="w-full mt-1 save-state">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium" data-lang="text-order">文字の順序 (レイヤー)</label>
                                    <div class="flex justify-around text-sm mt-1">
                                        <label><input type="radio" name="text-order" value="top" class="save-state"> <span data-lang="order-top">上から</span></label>
                                        <label><input type="radio" name="text-order" value="bottom" class="save-state"> <span data-lang="order-bottom">下から</span></label>
                                        <label><input type="radio" name="text-order" value="random" checked class="save-state"> <span data-lang="order-random">ランダム</span></label>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium" data-lang="text-placement">画面内の配置</label>
                                     <div class="flex justify-around text-sm mt-1">
                                        <label><input type="radio" name="text-placement" value="random" class="save-state"> <span data-lang="placement-random">ランダム</span></label>
                                        <label><input type="radio" name="text-placement" value="soft-avoid" checked class="save-state"> <span data-lang="placement-soft">ソフト</span></label>
                                        <label><input type="radio" name="text-placement" value="avoid-overlap" class="save-state"> <span data-lang="placement-avoid">重複を避ける</span></label>
                                    </div>
                                </div>

                                <!-- 文字色など -->
                                <div class="setting-group pt-3 border-t mt-3">
                                    <label class="block text-sm font-medium" data-lang="font-color">文字色</label>
                                    <div class="flex gap-4 text-sm mt-1 items-center">
                                        <label><input type="radio" name="font-color-mode" value="random" checked class="save-state"> <span data-lang="mode-random">ランダム</span></label>
                                        <label class="flex items-center">
                                            <input type="radio" name="font-color-mode" value="specify" class="save-state"> 
                                            <span class="ml-1" data-lang="mode-specify">指定</span>
                                            <input type="number" id="font-color-count" value="1" min="1" max="7" class="w-12 ml-2 p-0.5 border rounded-md text-center specify-control save-state" style="display: none;">
                                        </label>
                                    </div>
                                    <div id="font-color-pickers" class="flex gap-2 mt-2 flex-wrap"></div>
                                </div>

                                <div class="space-y-2 text-sm">
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-bold">太字</span>
                                        <div class="flex gap-3"><label class="flex items-center"><input type="radio" name="font-bold-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random">ランダム</span></label><label class="flex items-center"><input type="radio" name="font-bold-mode" value="on" class="save-state"> <span class="ml-1">On</span></label><label class="flex items-center"><input type="radio" name="font-bold-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label></div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-italic">斜体</span>
                                        <div class="flex gap-3"><label class="flex items-center"><input type="radio" name="font-italic-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random">ランダム</span></label><label class="flex items-center"><input type="radio" name="font-italic-mode" value="on" class="save-state"> <span class="ml-1">On</span></label><label class="flex items-center"><input type="radio" name="font-italic-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label></div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-shadow">影</span>
                                        <div class="flex gap-3"><label class="flex items-center"><input type="radio" name="font-shadow-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random">ランダム</span></label><label class="flex items-center"><input type="radio" name="font-shadow-mode" value="on" class="save-state"> <span class="ml-1">On</span></label><label class="flex items-center"><input type="radio" name="font-shadow-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label></div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-stroke">縁取り</span>
                                        <div class="flex gap-3"><label class="flex items-center"><input type="radio" name="font-stroke-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random">ランダム</span></label><label class="flex items-center"><input type="radio" name="font-stroke-mode" value="on" class="save-state"> <span class="ml-1">On</span></label><label class="flex items-center"><input type="radio" name="font-stroke-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label></div>
                                    </div>
                                </div>
                                

                                <div class="setting-group">
                                    <label class="block text-sm font-medium" data-lang="font-stroke-color">縁取りの色</label>
                                     <div class="flex gap-4 text-sm mt-1 items-center">
                                        <label><input type="radio" name="font-stroke-color-mode" value="random" checked class="save-state"> <span data-lang="mode-random">ランダム</span></label>
                                        <label class="flex items-center">
                                            <input type="radio" name="font-stroke-color-mode" value="specify" class="save-state">
                                            <span class="ml-1" data-lang="mode-specify">指定</span>
                                            <input type="number" id="font-stroke-color-count" value="1" min="1" max="7" class="w-12 ml-2 p-0.5 border rounded-md text-center specify-control save-state" style="display: none;">
                                        </label>
                                    </div>
                                    <div id="font-stroke-color-pickers" class="flex gap-2 mt-2 flex-wrap"></div>
                                </div>
                                <button id="reset-random-settings" class="btn bg-orange-500 text-white w-full py-1.5 rounded-md text-sm mt-4 hover:bg-orange-600" data-lang="reset-settings">設定をリセット</button>
                            </div>
                        </div>
                    </div>

                    <!-- フォント設定 -->
                    <div>
                        <button class="accordion-toggle w-full text-left font-semibold p-2 bg-gray-200 rounded-md hover:bg-gray-300" data-target="#font-settings">
                           <span data-lang="accordion-font">フォント設定</span>
                        </button>
                        <div id="font-settings" class="accordion-content">
                           <div class="p-4 space-y-2">
                                <div class="flex gap-2">
                                    <button id="font-select-all" class="btn bg-gray-200 text-gray-700 text-xs py-1 px-2 rounded-md w-full">全て選択</button>
                                    <button id="font-deselect-all" class="btn bg-gray-200 text-gray-700 text-xs py-1 px-2 rounded-md w-full">全て解除</button>
                                </div>
                                <div id="font-selection-list" class="mt-2 max-h-[36rem] overflow-y-auto pr-2"></div>
                           </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 画像出力パネル (非表示) -->
            <div id="image-output-panel" class="hidden">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold" data-lang="panel-title-output">画像出力</h2>
                    <button class="panel-back-btn btn text-sm text-indigo-600 border border-gray-300 px-2 py-1 rounded-md hover:bg-gray-100" data-lang="btn-back">戻る</button>
                </div>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium" data-lang="output-format">フォーマット</label>
                        <select id="output-format" class="w-full p-2 border rounded-md mt-1">
                            <option value="png">PNG</option>
                            <option value="jpeg">JPEG</option>
                        </select>
                    </div>
                    <button id="download-btn" class="btn bg-indigo-600 text-white w-full py-2 rounded-md font-bold hover:bg-indigo-700" data-lang="btn-download">ダウンロード</button>
                </div>
            </div>

            <!-- 操作説明パネル (非表示) -->
            <div id="help-panel" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold" data-lang="panel-title-help">操作説明</h2>
                    <button class="panel-back-btn btn text-sm text-indigo-600 border border-gray-300 px-2 py-1 rounded-md hover:bg-gray-100" data-lang="btn-back">戻る</button>
                </div>
                 <div class="text-sm space-y-3" data-lang-html="help-content">
                 </div>
            </div>
        </div>

        <!-- 右パネル (キャンバス) -->
        <div id="canvas-container" class="flex-grow bg-white rounded-lg shadow-lg flex items-center justify-center p-2 overflow-auto relative">
            <canvas id="main-canvas" class="border"></canvas>
            <div id="notification-area" class="absolute bottom-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-lg hidden" role="alert"></div>
            <!-- テキスト編集エリア -->
            <div id="text-editor-container">
                <textarea id="text-editor"></textarea>
                <div id="text-editor-buttons">
                    <button id="text-editor-ok" class="btn bg-green-500 text-white px-2 py-1 text-xs rounded">OK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM要素の取得 ---
            const canvasContainer = document.getElementById('canvas-container');
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const textDropArea = document.getElementById('text-drop-area');
            const textFileInput = document.getElementById('text-file-input');
            const deleteTextBtn = document.getElementById('delete-text-btn');
            const bgImageDropArea = document.getElementById('bg-image-drop-area');
            const bgImageInput = document.getElementById('bg-image-input');
            const deleteBgImageBtn = document.getElementById('delete-bg-image-btn');
            const generateBtn = document.getElementById('generate-btn');
            const downloadBtn = document.getElementById('download-btn');
            const notificationArea = document.getElementById('notification-area');
            const saveSettingsBtn = document.getElementById('btn-save-settings');
            const loadSettingsBtn = document.getElementById('btn-load-settings');
            const settingsFileInput = document.getElementById('settings-file-input');
            const fontSelectAllBtn = document.getElementById('font-select-all');
            const fontDeselectAllBtn = document.getElementById('font-deselect-all');
            const textEditorContainer = document.getElementById('text-editor-container');
            const textEditor = document.getElementById('text-editor');
            const textEditorOkBtn = document.getElementById('text-editor-ok');
            const resetRandomSettingsBtn = document.getElementById('reset-random-settings');

            // --- 状態管理 ---
            let textLines = [];
            let bgImage = null;
            let lastGeneratedLayout = [];
            const fontList = [
                'Noto Sans JP', 'Zen Kaku Gothic New', 'M PLUS Rounded 1c', 'BIZ UDPGothic', 
                'Kosugi Maru', 'Sawarabi Gothic', 'Shippori Mincho', 'Hina Mincho', 'Yuji Syuku', 
                'Kaisei Opti', 'Kaisei Decol', 'Kiwi Maru', 'Yusei Magic', 'DotGothic16', 
                'Dela Gothic One', 'Mochiy Pop One', 'Potta One', 'RocknRoll One',
                'Klee One', 'Stick', 'Rampart One', 'Train One', 'Zen Maru Gothic', 'Yomogi'
            ];
            let currentLang = 'ja';

            // --- ドラッグ＆ドロップ編集用の状態 ---
            let selectedTextIndex = -1;
            let isDragging = false;
            let dragOffsetX, dragOffsetY;
            let isEditing = false;

            // --- UI翻訳データ ---
            const translations = {
                'ja': {
                    'app-title': 'ランダム文字配置メーカー', 'btn-image-output': '画像出力', 'btn-help': '操作説明',
                    'btn-save': '保存', 'btn-load': '呼出', 'lang-switch': 'English',
                    'text-drop-area': 'テキストファイル(.txt)をここにドロップ<br>またはクリックして選択',
                    'delete-text': 'テキストを削除', 'delete-bg-image': '背景画像を削除', 'generate-btn': '作成',
                    'accordion-field': 'フィールド設定', 'accordion-font': 'フォント設定', 'canvas-size': '画面サイズ',
                    'bg-color': '背景色', 'transparent-bg': '背景を透過 (PNG出力時)', 'bg-image-drop-area': '背景画像をドロップ',
                    'bg-opacity': '背景画像の透過度', 'bg-scale': '背景画像の拡大縮小',
                    'accordion-random': 'ランダム処理の設定', 'mode-specify': '指定', 'mode-random': 'ランダム',
                    'mode-random-short': 'R', 'font-color': '文字色', 'font-bold': '太字', 'font-italic': '斜体',
                    'font-shadow': '影', 'font-stroke': '縁取り', 'font-stroke-color': '縁取りの色',
                    'font-size': 'フォントサイズ (最小 - 最大)', 'text-opacity': '文字の透過度', 'writing-mode': '縦書きの比率',
                    'text-order': '文字の順序 (レイヤー)', 'order-top': '上から', 'order-bottom': '下から',
                    'order-random': 'ランダム', 'text-placement': '画面内の配置', 'placement-random': 'ランダム',
                    'placement-soft': 'ソフト', 'placement-avoid': '重複を避ける', 'panel-title-output': '画像出力', 'btn-back': '戻る',
                    'output-format': 'フォーマット', 'btn-download': 'ダウンロード', 'panel-title-help': '操作説明',
                    'initial-text': 'ここに画像が生成されます', 'unplaced-text': '{count}個の文章を配置できませんでした。', 'reset-settings': '設定をリセット',
                    'help-content': `
                        <p><b>1. テキストを用意する</b></p>
                        <p>左上のエリアにテキストファイル (.txt) をドラッグ＆ドロップします。ファイル内の改行が、一つの文章として認識されます。</p>
                        <p><b>2. 設定を調整する</b></p>
                        <p>各項目を開き、背景や文字のスタイル、ランダム化のルールを自由に調整できます。</p>
                        <p><b>3. 作成ボタンを押す</b></p>
                        <p>「作成」ボタンで、右側のフィールドに文章がランダムに配置されます。配置後に各文章をドラッグして位置を微調整できます。</p>
                        <p><b>4. テキストを編集する</b></p>
                        <p>キャンバス上のテキストをダブルクリックすると、その場で内容を編集できます。</p>
                        <p><b>5. 保存・呼出</b></p>
                        <p>「保存」で現在の設定をファイルとして保存し、「呼出」でそのファイルを読み込んで設定を復元できます。</p>
                        <p><b>6. 画像を出力する</b></p>
                        <p>「画像出力」ボタンでパネルを切り替え、好きなフォーマットで画像をダウンロードできます。</p>
                    `
                },
                'en': {
                    'app-title': 'Random Text Placer', 'btn-image-output': 'Export', 'btn-help': 'Help',
                    'btn-save': 'Save', 'btn-load': 'Load', 'lang-switch': '日本語',
                    'text-drop-area': 'Drop text file (.txt) here<br>or click to select',
                    'delete-text': 'Delete text', 'delete-bg-image': 'Delete background image', 'generate-btn': 'Generate',
                    'accordion-field': 'Field Settings', 'accordion-font': 'Font Settings', 'canvas-size': 'Canvas Size',
                    'bg-color': 'Background Color', 'transparent-bg': 'Transparent BG (on PNG export)', 'bg-image-drop-area': 'Drop background image',
                    'bg-opacity': 'BG Image Opacity', 'bg-scale': 'BG Image Scale',
                    'accordion-random': 'Randomization Settings', 'mode-specify': 'Specify', 'mode-random': 'Random',
                    'mode-random-short': 'R', 'font-color': 'Font Color', 'font-bold': 'Bold', 'font-italic': 'Italic',
                    'font-shadow': 'Shadow', 'font-stroke': 'Stroke', 'font-stroke-color': 'Stroke Color',
                    'font-size': 'Font Size (Min - Max)', 'text-opacity': 'Text Opacity', 'writing-mode': 'Vertical Ratio',
                    'text-order': 'Text Order (Layer)', 'order-top': 'Top-down', 'order-bottom': 'Bottom-up',
                    'order-random': 'Random', 'text-placement': 'Placement', 'placement-random': 'Random',
                    'placement-soft': 'Soft', 'placement-avoid': 'Avoid Overlap', 'panel-title-output': 'Export Image', 'btn-back': 'Back',
                    'output-format': 'Format', 'btn-download': 'Download', 'panel-title-help': 'Instructions',
                    'initial-text': 'Image will be generated here', 'unplaced-text': 'Could not place {count} sentences.', 'reset-settings': 'Reset Settings',
                    'help-content': `
                        <p><b>1. Prepare Text</b></p>
                        <p>Drag & drop a text file (.txt) into the top-left area. Each line break creates a new sentence.</p>
                        <p><b>2. Adjust Settings</b></p>
                        <p>Open each section to customize the background, text styles, and randomization rules.</p>
                        <p><b>3. Generate</b></p>
                        <p>Press "Generate" to place text on the canvas. You can then drag each sentence to adjust its position.</p>
                        <p><b>4. Edit Text</b></p>
                        <p>Double-click any text on the canvas to edit its content directly.</p>
                        <p><b>5. Save & Load</b></p>
                        <p>Use "Save" to download your current settings, and "Load" to restore them from a file.</p>
                        <p><b>6. Export Image</b></p>
                        <p>Click "Export", choose a format, and download your final image.</p>
                    `
                }
            };

            // --- UI初期化 ---
            function populateFontList() {
                const container = document.getElementById('font-selection-list');
                container.innerHTML = '';
                fontList.forEach(font => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between text-sm pb-2 mb-2 border-b border-gray-200';
                    div.innerHTML = `
                        <div class="flex items-center">
                            <input type="checkbox" id="font-check-${font.replace(/\s/g, '')}" value="${font}" checked class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 save-state">
                            <label for="font-check-${font.replace(/\s/g, '')}" class="ml-2">${font}</label>
                        </div>
                        <span style="font-family: '${font}', sans-serif; font-size: 22px;">Aa亜あア！？</span>
                    `;
                    container.appendChild(div);
                });
            }

            // --- イベントリスナー ---
            // アコーディオン
            document.querySelectorAll('.accordion-toggle').forEach(button => {
                button.addEventListener('click', () => {
                    document.querySelectorAll('.accordion-content').forEach(otherContent => {
                        if (otherContent !== document.querySelector(button.dataset.target)) {
                            otherContent.style.maxHeight = null;
                        }
                    });
                    const content = document.querySelector(button.dataset.target);
                    content.style.maxHeight = content.style.maxHeight ? null : content.scrollHeight + "px";
                });
            });

            // フォントサイズスライダーの値表示
            ['min', 'max'].forEach(type => {
                const slider = document.getElementById(`font-size-${type}`);
                const display = document.getElementById(`font-size-${type}-val`);
                slider.addEventListener('input', () => display.textContent = slider.value);
            });

            // ファイルドロップ共通処理
            const setupDropArea = (area, input, onFileLoad) => {
                area.addEventListener('click', () => input.click());
                area.addEventListener('dragover', (e) => { e.preventDefault(); area.classList.add('dragover'); });
                area.addEventListener('dragleave', () => area.classList.remove('dragover'));
                area.addEventListener('drop', (e) => {
                    e.preventDefault();
                    area.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file) onFileLoad(file);
                });
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) onFileLoad(file);
                });
            };

            // アコーディオンの高さ再計算
            const refreshAccordionHeight = (element) => {
                const content = element.closest('.accordion-content');
                if (content && content.style.maxHeight) {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            };
            
            // テキストファイルのドロップ
            setupDropArea(textDropArea, textFileInput, (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    textLines = e.target.result.split(/\r\n|\n/).filter(line => line.trim() !== '');
                    textDropArea.querySelector('span').textContent = file.name;
                    deleteTextBtn.classList.remove('hidden');
                    refreshAccordionHeight(deleteTextBtn);
                };
                reader.readAsText(file);
            });
            deleteTextBtn.addEventListener('click', () => {
                textLines = [];
                textFileInput.value = '';
                textDropArea.querySelector('span').innerHTML = translations[currentLang]['text-drop-area'];
                deleteTextBtn.classList.add('hidden');
                lastGeneratedLayout = [];
                redrawCanvas();
                refreshAccordionHeight(deleteTextBtn);
            });

            // 背景画像のドロップ
            setupDropArea(bgImageDropArea, bgImageInput, (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    bgImage = new Image();
                    bgImage.onload = () => { 
                        bgImageDropArea.querySelector('span').textContent = file.name; 
                        deleteBgImageBtn.classList.remove('hidden');
                        redrawCanvas();
                        refreshAccordionHeight(deleteBgImageBtn);
                    };
                    bgImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
            deleteBgImageBtn.addEventListener('click', () => {
                bgImage = null;
                bgImageInput.value = '';
                bgImageDropArea.querySelector('span').textContent = translations[currentLang]['bg-image-drop-area'];
                deleteBgImageBtn.classList.add('hidden');
                redrawCanvas();
                refreshAccordionHeight(deleteBgImageBtn);
            });
            
            // パネル切り替え
            const panels = { settings: document.getElementById('settings-panel'), output: document.getElementById('image-output-panel'), help: document.getElementById('help-panel') };
            const headerBtns = { output: document.getElementById('btn-image-output'), help: document.getElementById('btn-help') };
            const switchPanel = (panelName) => {
                Object.values(panels).forEach(p => p.classList.add('hidden'));
                if(panels[panelName]) panels[panelName].classList.remove('hidden');
                headerBtns.output.classList.remove('active-purple');
                headerBtns.help.classList.remove('active-green');
                if (panelName === 'output') headerBtns.output.classList.add('active-purple');
                else if (panelName === 'help') headerBtns.help.classList.add('active-green');
            };
            headerBtns.output.addEventListener('click', () => switchPanel('output'));
            headerBtns.help.addEventListener('click', () => switchPanel('help'));
            document.querySelectorAll('.panel-back-btn').forEach(btn => btn.addEventListener('click', () => switchPanel('settings')));

            // 言語切り替え
            const langSwitchBtn = document.getElementById('btn-lang-switch');
            const switchLanguage = (lang) => {
                currentLang = lang;
                document.documentElement.lang = lang;
                const data = translations[lang];
                document.querySelectorAll('[data-lang]').forEach(el => el.textContent = data[el.dataset.lang] || el.textContent);
                document.querySelectorAll('[data-lang-html]').forEach(el => el.innerHTML = data[el.dataset.langHtml] || el.innerHTML);
                langSwitchBtn.textContent = data['lang-switch'];
                redrawCanvas();
            };
            langSwitchBtn.addEventListener('click', () => switchLanguage(currentLang === 'ja' ? 'en' : 'ja'));

            // リアルタイム更新
            document.querySelectorAll('.realtime-update').forEach(el => el.addEventListener('input', redrawCanvas));
            
            generateBtn.addEventListener('click', generateLayout);

            // --- メインロジック ---
            function generateLayout() {
                notificationArea.classList.add('hidden');
                lastGeneratedLayout = [];
                
                const settings = getSettings();
                const activeFonts = getActiveFonts();

                if (textLines.length === 0 || activeFonts.length === 0) {
                    redrawCanvas();
                    return;
                }

                let linesToDraw = [...textLines];
                if (settings.textOrder === 'bottom') linesToDraw.reverse();
                if (settings.textOrder === 'random') linesToDraw.sort(() => Math.random() - 0.5);
                
                const placedRects = [];
                let unplacedCount = 0;

                // 色の均等分配のための準備
                const shuffledFontColors = [...settings.fontColors].sort(() => 0.5 - Math.random());
                const shuffledStrokeColors = [...settings.fontStrokeColors].sort(() => 0.5 - Math.random());
                let fontColorIndex = 0;
                let strokeColorIndex = 0;

                linesToDraw.forEach(line => {
                    const style = {
                        fontFamily: activeFonts[Math.floor(Math.random() * activeFonts.length)],
                        fontColor: settings.fontColorMode === 'random' ? getRandomColor() : shuffledFontColors[fontColorIndex++ % shuffledFontColors.length],
                        fontStrokeColor: settings.fontStrokeColorMode === 'random' ? getRandomColor() : shuffledStrokeColors[strokeColorIndex++ % shuffledStrokeColors.length],
                        fontBold: (settings.fontBoldMode === 'on') ? true : (settings.fontBoldMode === 'off') ? false : Math.random() < 0.5,
                        fontItalic: (settings.fontItalicMode === 'on') ? true : (settings.fontItalicMode === 'off') ? false : Math.random() < 0.5,
                        fontShadow: (settings.fontShadowMode === 'on') ? true : (settings.fontShadowMode === 'off') ? false : Math.random() < 0.5,
                        fontStroke: (settings.fontStrokeMode === 'on') ? true : (settings.fontStrokeMode === 'off') ? false : Math.random() < 0.5,
                        opacity: settings.textOpacityMode === 'random' ? Math.random() : settings.textOpacity,
                    };
                    const fontSize = Math.random() * (settings.fontSizeMax - settings.fontSizeMin) + settings.fontSizeMin;
                    const isVertical = Math.random() * 100 < settings.verticalRatio;

                    // 位置決め
                    let bestPosition = null;
                    let minOverlap = Infinity;
                    const maxAttempts = settings.textPlacement === 'avoid-overlap' ? 200 : (settings.textPlacement === 'soft-avoid' ? 50 : 1);

                    for (let i = 0; i < maxAttempts; i++) {
                        const metrics = getMetrics(line, fontSize, style, isVertical);
                        
                        const x = Math.random() * (settings.width - metrics.width);
                        const y = Math.random() * (settings.height - metrics.height);
                        const currentRect = { x, y, width: metrics.width, height: metrics.height };

                        if (settings.textPlacement === 'soft-avoid') {
                            let currentOverlap = 0;
                            for (const placedRect of placedRects) {
                                currentOverlap += calculateOverlapArea(currentRect, placedRect);
                            }
                            if (currentOverlap < minOverlap) {
                                minOverlap = currentOverlap;
                                bestPosition = { x, y, rect: currentRect };
                            }
                            if (minOverlap === 0) break;
                        } else { // 'random' or 'avoid-overlap'
                            if (!isOverlapping(currentRect, placedRects)) {
                                bestPosition = { x, y, rect: currentRect };
                                break;
                            }
                            if (settings.textPlacement === 'random') {
                                bestPosition = { x, y, rect: currentRect };
                                break;
                            }
                        }
                    }

                    if (bestPosition) {
                        lastGeneratedLayout.push({ line, style, fontSize, isVertical, position: bestPosition });
                        placedRects.push(bestPosition.rect);
                    } else if (settings.textPlacement !== 'random') {
                        unplacedCount++;
                    }
                });

                if (unplacedCount > 0) {
                    notificationArea.textContent = translations[currentLang]['unplaced-text'].replace('{count}', unplacedCount);
                    notificationArea.classList.remove('hidden');
                }

                redrawCanvas();
            }

            function redrawCanvas() {
                const settings = getSettings();
                canvas.width = settings.width;
                canvas.height = settings.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 背景色を先に描画
                ctx.fillStyle = settings.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 背景画像を次に描画
                if (bgImage) {
                    ctx.globalAlpha = settings.bgOpacity;
                    const w = bgImage.width * settings.bgScale;
                    const h = bgImage.height * settings.bgScale;
                    ctx.drawImage(bgImage, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
                    ctx.globalAlpha = 1.0;
                }
                
                // 初期メッセージ
                if (lastGeneratedLayout.length === 0) {
                    ctx.font = "24px 'Noto Sans JP'";
                    ctx.fillStyle = "#AAAAAA";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(translations[currentLang]['initial-text'], canvas.width / 2, canvas.height / 2);
                    return;
                }

                // テキスト描画
                lastGeneratedLayout.forEach(item => {
                    const { line, style, fontSize, isVertical, position } = item;
                    
                    ctx.globalAlpha = style.opacity;
                    ctx.font = `${style.fontItalic ? 'italic ' : ''}${style.fontBold ? 'bold ' : ''} ${fontSize}px "${style.fontFamily}"`;
                    ctx.fillStyle = style.fontColor;
                    ctx.strokeStyle = style.fontStrokeColor;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = style.fontShadow ? 'rgba(0, 0, 0, 0.5)' : 'transparent';
                    ctx.shadowBlur = style.fontShadow ? 5 : 0;
                    ctx.shadowOffsetX = style.fontShadow ? 2 : 2;
                    ctx.shadowOffsetY = style.fontShadow ? 2 : 2;
                    
                    if (isVertical) {
                        drawVerticalText(item);
                    } else {
                        drawHorizontalWrappedText(item);
                    }
                });
                // シャドウと透過度をリセット
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.globalAlpha = 1.0;
            }

            // --- ヘルパー関数 ---
            function getSettings() {
                const getColors = (type) => Array.from(document.querySelectorAll(`#${type}-pickers input[type="color"]:not(:disabled)`)).map(p => p.value);
                return {
                    width: parseInt(document.getElementById('canvas-width').value, 10),
                    height: parseInt(document.getElementById('canvas-height').value, 10),
                    bgColor: document.getElementById('bg-color').value,
                    transparentBg: document.getElementById('transparent-bg').checked,
                    bgOpacity: parseFloat(document.getElementById('bg-opacity').value),
                    bgScale: parseFloat(document.getElementById('bg-scale').value),
                    fontColorMode: document.querySelector('input[name="font-color-mode"]:checked').value,
                    fontStrokeColorMode: document.querySelector('input[name="font-stroke-color-mode"]:checked').value,
                    fontBoldMode: document.querySelector('input[name="font-bold-mode"]:checked').value,
                    fontItalicMode: document.querySelector('input[name="font-italic-mode"]:checked').value,
                    fontShadowMode: document.querySelector('input[name="font-shadow-mode"]:checked').value,
                    fontStrokeMode: document.querySelector('input[name="font-stroke-mode"]:checked').value,
                    fontColors: getColors('font-color').length > 0 ? getColors('font-color') : ['#000000'],
                    fontStrokeColors: getColors('font-stroke-color').length > 0 ? getColors('font-stroke-color') : ['#FFFFFF'],
                    fontSizeMin: parseInt(document.getElementById('font-size-min').value, 10),
                    fontSizeMax: parseInt(document.getElementById('font-size-max').value, 10),
                    textOpacityMode: document.querySelector('input[name="text-opacity-mode"]:checked').value,
                    textOpacity: parseFloat(document.getElementById('text-opacity').value),
                    verticalRatio: parseInt(document.getElementById('vertical-ratio').value, 10),
                    textOrder: document.querySelector('input[name="text-order"]:checked').value,
                    textPlacement: document.querySelector('input[name="text-placement"]:checked').value,
                };
            }
            
            function getActiveFonts() {
                const checked = Array.from(document.querySelectorAll('#font-selection-list input:checked')).map(cb => cb.value);
                return checked.length > 0 ? checked : ['Noto Sans JP'];
            }
            
            function hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }

            function getRandomColor() {
                const hue = Math.random() * 360;
                const saturation = 70 + Math.random() * 30; // 70-100%
                const lightness = 50 + Math.random() * 10; // 50-60%
                return hslToHex(hue, saturation, lightness);
            }

            function getMetrics(text, fontSize, style, isVertical) {
                ctx.font = `${style.fontItalic ? 'italic ' : ''}${style.fontBold ? 'bold ' : ''} ${fontSize}px "${style.fontFamily}"`;
                const lines = text.split('\n');
                if (isVertical) {
                    const height = Math.max(...lines.map(l => l.length)) * fontSize;
                    const width = lines.length * fontSize;
                    return { width, height };
                } else {
                    const width = Math.max(...lines.map(l => ctx.measureText(l).width));
                    const height = lines.length * fontSize * 1.2; // 行間を考慮
                    return { width, height };
                }
            }
            
            function drawHorizontalWrappedText(item, targetCtx = ctx) {
                const { line, style, fontSize, position } = item;
                const { x, y, rect } = position;
                const maxWidth = rect.width;
                const lineHeight = fontSize * 1.2;

                targetCtx.textAlign = "left";
                targetCtx.textBaseline = "top";

                const paragraphs = line.split('\n');
                let currentY = y;

                for (const paragraph of paragraphs) {
                    if (paragraph === '') {
                        currentY += lineHeight;
                        continue;
                    }
                    let currentLine = '';
                    const words = paragraph.split('');
                    for (let i = 0; i < words.length; i++) {
                        const testLine = currentLine + words[i];
                        if (targetCtx.measureText(testLine).width > maxWidth && currentLine.length > 0) {
                            if (style.fontStroke) targetCtx.strokeText(currentLine, x, currentY);
                            targetCtx.fillText(currentLine, x, currentY);
                            currentLine = words[i];
                            currentY += lineHeight;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    if (style.fontStroke) targetCtx.strokeText(currentLine, x, currentY);
                    targetCtx.fillText(currentLine, x, currentY);
                    currentY += lineHeight;
                }
            }

            function drawVerticalText(item, targetCtx = ctx) {
                const { line, style, fontSize, position } = item;
                const { x, y } = position;
                const lines = line.split('\n');
                const charsToRotate = ['ー', '…', '(', ')', '（', '）', '[', ']', '［', '］', '{', '}', '｛', '｝', '~', '～'];
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';

                lines.forEach((line, lineIndex) => {
                    const lineX = x + (lines.length - 1 - lineIndex) * fontSize;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        const charX = lineX + fontSize / 2;
                        const charY = y + (i * fontSize) + (fontSize / 2);

                        if (charsToRotate.includes(char)) {
                            targetCtx.save();
                            targetCtx.translate(charX, charY);
                            targetCtx.rotate(Math.PI / 2);
                            if (style.fontStroke) targetCtx.strokeText(char, 0, 0);
                            targetCtx.fillText(char, 0, 0);
                            targetCtx.restore();
                        } else {
                            if (style.fontStroke) targetCtx.strokeText(char, charX, charY);
                            targetCtx.fillText(char, charX, charY);
                        }
                    }
                });
            }

            function isOverlapping(rect1, rects) {
                for (const rect2 of rects) {
                    if (!(rect1.x > rect2.x + rect2.width || rect1.x + rect1.width < rect2.x || rect1.y > rect2.y + rect2.height || rect1.y + rect1.height < rect2.y)) return true;
                }
                return false;
            }

            function calculateOverlapArea(rect1, rect2) {
                const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
                const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
                return x_overlap * y_overlap;
            }
            
            function isPointInRect(px, py, rect) {
                return px >= rect.x && px <= rect.x + rect.width && py >= rect.y && py <= rect.y + rect.height;
            }

            // --- インタラクティブ機能 (ドラッグ＆編集) ---
            canvas.addEventListener('mousedown', (e) => {
                if (isEditing) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                for (let i = lastGeneratedLayout.length - 1; i >= 0; i--) {
                    if (isPointInRect(mouseX, mouseY, lastGeneratedLayout[i].position.rect)) {
                        selectedTextIndex = i;
                        isDragging = true;
                        dragOffsetX = mouseX - lastGeneratedLayout[i].position.x;
                        dragOffsetY = mouseY - lastGeneratedLayout[i].position.y;
                        canvas.classList.add('dragging');
                        return;
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isEditing) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (isDragging && selectedTextIndex !== -1) {
                    const selectedItem = lastGeneratedLayout[selectedTextIndex];
                    selectedItem.position.x = mouseX - dragOffsetX;
                    selectedItem.position.y = mouseY - dragOffsetY;
                    selectedItem.position.rect.x = selectedItem.position.x;
                    selectedItem.position.rect.y = selectedItem.position.y;
                    redrawCanvas();
                } else {
                    let onText = false;
                    for (let i = lastGeneratedLayout.length - 1; i >= 0; i--) {
                        if (isPointInRect(mouseX, mouseY, lastGeneratedLayout[i].position.rect)) {
                            onText = true;
                            break;
                        }
                    }
                    canvas.classList.toggle('draggable', onText);
                }
            });

            const stopDragging = () => {
                isDragging = false;
                canvas.classList.remove('dragging');
            };
            canvas.addEventListener('mouseup', stopDragging);
            canvas.addEventListener('mouseout', stopDragging);

            canvas.addEventListener('dblclick', (e) => {
                if (isEditing) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                for (let i = lastGeneratedLayout.length - 1; i >= 0; i--) {
                    if (isPointInRect(mouseX, mouseY, lastGeneratedLayout[i].position.rect)) {
                        startEditing(i);
                        return;
                    }
                }
            });

            function startEditing(index) {
                isEditing = true;
                selectedTextIndex = index;
                const item = lastGeneratedLayout[index];
                const { line, style, fontSize, isVertical, position } = item;

                textEditor.value = line;
                textEditor.style.font = `${style.fontItalic ? 'italic ' : ''}${style.fontBold ? 'bold ' : ''} ${fontSize}px "${style.fontFamily}"`;
                textEditor.style.color = '#000000'; // Always black for editing
                textEditor.style.lineHeight = '1.2';

                const tempCtx = document.createElement('canvas').getContext('2d');
                tempCtx.font = textEditor.style.font;
                const lines = line.split('\n');
                let requiredWidth, requiredHeight;

                if (isVertical) {
                    textEditor.classList.remove('horizontal');
                    textEditor.classList.add('vertical');
                    requiredWidth = lines.length * fontSize + 20;
                    requiredHeight = Math.max(...lines.map(l => l.length)) * fontSize + 20;
                } else {
                    textEditor.classList.remove('vertical');
                    textEditor.classList.add('horizontal');
                    requiredWidth = Math.max(...lines.map(l => tempCtx.measureText(l).width)) + 20;
                    requiredHeight = lines.length * fontSize * 1.2 + 20;
                }
                
                requiredWidth = Math.max(requiredWidth, 50);
                requiredHeight = Math.max(requiredHeight, 40);

                let newLeft = position.x - 1;
                let newTop = position.y - 1;

                if (newLeft + requiredWidth > canvas.width) {
                    newLeft = canvas.width - requiredWidth - 5;
                }
                if (newTop + requiredHeight > canvas.height) {
                    newTop = canvas.height - requiredHeight - 30;
                }
                newLeft = Math.max(0, newLeft);
                newTop = Math.max(0, newTop);

                textEditor.style.width = `${requiredWidth}px`;
                textEditor.style.height = `${requiredHeight}px`;
                textEditorContainer.style.left = `${newLeft}px`;
                textEditorContainer.style.top = `${newTop}px`;

                textEditorContainer.style.display = 'flex';
                textEditor.focus();
                textEditor.setSelectionRange(0, 0);
            }

            function stopEditing(saveChanges) {
                if (!isEditing) return;
                if (saveChanges) {
                    const item = lastGeneratedLayout[selectedTextIndex];
                    item.line = textEditor.value;
                    
                    item.position.rect.width = textEditor.clientWidth;
                    item.position.rect.height = textEditor.clientHeight;
                }
                isEditing = false;
                selectedTextIndex = -1;
                textEditorContainer.style.display = 'none';
                redrawCanvas();
            }

            textEditorOkBtn.addEventListener('click', () => stopEditing(true));
            document.addEventListener('mousedown', (e) => {
                if (isEditing && !textEditorContainer.contains(e.target)) {
                    stopEditing(false); // 外側クリックはキャンセル
                }
            });


            // --- ダウンロード、設定保存/読込 ---
            downloadBtn.addEventListener('click', () => {
                const format = document.getElementById('output-format').value;
                const settings = getSettings();
                const isTransparent = settings.transparentBg && format === 'png';

                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                
                exportCanvas.width = settings.width;
                exportCanvas.height = settings.height;

                if (!isTransparent) {
                    exportCtx.fillStyle = settings.bgColor;
                    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
                }

                if (bgImage) {
                    exportCtx.globalAlpha = settings.bgOpacity;
                    const w = bgImage.width * settings.bgScale;
                    const h = bgImage.height * settings.bgScale;
                    exportCtx.drawImage(bgImage, (exportCanvas.width - w) / 2, (exportCanvas.height - h) / 2, w, h);
                }

                lastGeneratedLayout.forEach(item => {
                    const { style, fontSize, isVertical } = item;
                    exportCtx.globalAlpha = style.opacity;
                    exportCtx.font = `${style.fontItalic ? 'italic ' : ''}${style.fontBold ? 'bold ' : ''} ${fontSize}px "${style.fontFamily}"`;
                    exportCtx.fillStyle = style.fontColor;
                    exportCtx.strokeStyle = style.fontStrokeColor;
                    exportCtx.lineWidth = 2;
                    exportCtx.shadowColor = style.fontShadow ? 'rgba(0, 0, 0, 0.5)' : 'transparent';
                    exportCtx.shadowBlur = style.fontShadow ? 5 : 0;
                    exportCtx.shadowOffsetX = style.fontShadow ? 2 : 2;
                    exportCtx.shadowOffsetY = style.fontShadow ? 2 : 2;
                    
                    if (isVertical) {
                        drawVerticalText(item, exportCtx);
                    } else {
                        drawHorizontalWrappedText(item, exportCtx);
                    }
                });

                const link = document.createElement('a');
                link.download = `random-text-art.${format}`;
                link.href = exportCanvas.toDataURL(`image/${format}`, 1.0);
                link.click();
            });

            // カラーピッカーUIの管理
            function setupColorPickers(type) {
                const countInput = document.getElementById(`${type}-count`);
                const container = document.getElementById(`${type}-pickers`);
                const modeRadios = document.querySelectorAll(`input[name="${type}-mode"]`);
                const defaultColors = type === 'font-color' 
                    ? ['#000000', '#FF0000', '#0000FF', '#008000', '#FFFF00', '#800080', '#00FFFF'] 
                    : ['#FFFFFF', '#000000', '#FF0000', '#0000FF', '#008000', '#800080', '#00FFFF'];

                container.innerHTML = '';
                for (let i = 0; i < 7; i++) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'color-picker-wrapper';
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = defaultColors[i] || defaultColors[0];
                    colorInput.classList.add('save-state');
                    colorInput.id = `${type}-picker-${i}`;
                    wrapper.appendChild(colorInput);
                    container.appendChild(wrapper);
                }

                function updatePickerStates() {
                    const isSpecify = document.querySelector(`input[name="${type}-mode"]:checked`).value === 'specify';
                    const count = parseInt(countInput.value, 10);

                    countInput.style.display = isSpecify ? 'inline-block' : 'none';

                    container.querySelectorAll('.color-picker-wrapper').forEach((wrapper, i) => {
                        const picker = wrapper.querySelector('input[type="color"]');
                        const isDisabled = !isSpecify || i >= count;
                        
                        picker.disabled = isDisabled;
                        wrapper.classList.toggle('is-disabled', isDisabled);
                    });
                }

                countInput.addEventListener('input', updatePickerStates);
                modeRadios.forEach(radio => radio.addEventListener('change', updatePickerStates));
                
                updatePickerStates();
            }
            
            // 設定の保存/読込
            const settingsKey = 'randomTextPlacerSettings_v11';
            function getSettingsToSave() {
                const settings = {};
                document.querySelectorAll('.save-state').forEach(el => {
                    const key = el.id || el.name;
                    if (el.type === 'radio') {
                        if (el.checked) settings[key] = el.value;
                    } else if (el.type === 'checkbox') {
                        settings[key] = el.checked;
                    } else {
                        settings[key] = el.value;
                    }
                });
                return settings;
            }
            
            function applySettings(settings) {
                 Object.keys(settings).forEach(key => {
                    const el = document.getElementById(key);
                    if (el) {
                        if (el.type === 'checkbox') el.checked = settings[key];
                        else el.value = settings[key];
                        if (el.type === 'range') el.dispatchEvent(new Event('input'));
                    } else {
                        const radioGroup = document.querySelectorAll(`input[name="${key}"]`);
                        if (radioGroup.length > 0) {
                            radioGroup.forEach(radio => radio.checked = radio.value === settings[key]);
                        }
                    }
                });
                // UI更新イベントを発火
                document.querySelectorAll('input[name="font-color-mode"], input[name="font-stroke-color-mode"], input[name="text-opacity-mode"]').forEach(r => {
                    r.dispatchEvent(new Event('change'));
                    const countInput = document.getElementById(r.name.replace('-mode', '-count'));
                    if (countInput) countInput.dispatchEvent(new Event('input'));
                });
                redrawCanvas();
            }

            saveSettingsBtn.addEventListener('click', () => {
                const settings = getSettingsToSave();
                const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'settings.json';
                a.click();
                URL.revokeObjectURL(a.href);
            });

            loadSettingsBtn.addEventListener('click', () => settingsFileInput.click());
            settingsFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (re) => {
                    try {
                        applySettings(JSON.parse(re.target.result));
                    } catch (err) { console.error("Error parsing settings file:", err); }
                };
                reader.readAsText(file);
                e.target.value = '';
            });

            resetRandomSettingsBtn.addEventListener('click', () => {
                const container = document.getElementById('random-settings');
                // Reset inputs to default
                container.querySelectorAll('input.save-state').forEach(el => {
                    if (el.type === 'range') {
                        if(el.id === 'font-size-min') el.value = 16;
                        else if(el.id === 'font-size-max') el.value = 48;
                        else if(el.id === 'vertical-ratio') el.value = 50;
                        else if(el.id === 'text-opacity') el.value = 1;
                        el.dispatchEvent(new Event('input'));
                    } else if (el.type === 'number') {
                        el.value = 1;
                    }
                });
                // Reset radio buttons
                container.querySelectorAll('input[type="radio"].save-state').forEach(el => {
                    if(el.name === 'text-order' && el.value === 'random') el.checked = true;
                    if(el.name === 'text-placement' && el.value === 'soft-avoid') el.checked = true;
                    if(el.name === 'font-color-mode' && el.value === 'random') el.checked = true;
                    if(el.name === 'font-stroke-color-mode' && el.value === 'random') el.checked = true;
                    if(el.name === 'text-opacity-mode' && el.value === 'specify') el.checked = true;
                    if(['font-bold-mode', 'font-italic-mode', 'font-shadow-mode', 'font-stroke-mode'].includes(el.name) && el.value === 'random') el.checked = true;
                });
                // Trigger updates
                document.querySelectorAll('#random-settings input[type="radio"]').forEach(r => r.dispatchEvent(new Event('change')));
            });

            // --- 初期化処理 ---
            populateFontList();
            setupColorPickers('font-color');
            setupColorPickers('font-stroke-color');
            
            const textOpacityModeRadios = document.querySelectorAll('input[name="text-opacity-mode"]');
            const textOpacitySlider = document.getElementById('text-opacity');
            function updateOpacitySliderVisibility() {
                const isSpecify = document.querySelector('input[name="text-opacity-mode"]:checked').value === 'specify';
                textOpacitySlider.style.display = isSpecify ? 'block' : 'none';
                refreshAccordionHeight(textOpacitySlider);
            }
            textOpacityModeRadios.forEach(radio => radio.addEventListener('change', updateOpacitySliderVisibility));
            
            switchLanguage('ja');
            redrawCanvas();

            // フォント全選択/全解除
            fontSelectAllBtn.addEventListener('click', () => document.querySelectorAll('#font-selection-list input').forEach(cb => cb.checked = true));
            fontDeselectAllBtn.addEventListener('click', () => document.querySelectorAll('#font-selection-list input').forEach(cb => cb.checked = false));
        
            // 初期状態でUIを更新
            updateOpacitySliderVisibility();
        });
    </script>
</body>
</html>
