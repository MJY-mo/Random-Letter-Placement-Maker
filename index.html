<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ランダム文字配置メーカー</title>
    <link rel="icon" href="favicon11.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic&family=Dela+Gothic+One&family=DotGothic16&family=Hina+Mincho&family=Kaisei+Decol&family=Kaisei+Opti&family=Kiwi+Maru&family=Kosugi+Maru&family=M+PLUS+Rounded+1c:wght@400;700&family=Mochiy+Pop+One&family=Noto+Sans+JP:wght@400;700&family=Potta+One&family=RocknRoll+One&family=Sawarabi+Gothic&family=Shippori+Mincho&family=Yuji+Syuku&family=Yusei+Magic&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* カスタムスタイル */
        body {
            font-family: 'Noto Sans JP', sans-serif;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background-color: #f9fafb; /* bg-gray-50 */
            border-radius: 0 0 0.375rem 0.375rem; /* rounded-b-md */
        }
        .drop-area {
            border: 2px dashed #ccc;
            transition: border-color 0.3s, background-color 0.3s;
        }
        .drop-area.dragover {
            border-color: #4f46e5;
            background-color: #e0e7ff;
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .btn-purple { background-color: #8b5cf6; color: white; }
        .btn-green { background-color: #22c55e; color: white; }
        .btn-gray { background-color: #6b7280; color: white; }
        .btn-gray.active {
             box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.4);
        }
        .btn-gray.active-purple { background-color: #8b5cf6; }
        .btn-gray.active-green { background-color: #22c55e; }
        /* ラジオボタンの隣のUIを無効化/非表示にするスタイル */
        .setting-group input[type="radio"][value="random"]:checked ~ .specify-control,
        .setting-group input[type="radio"][value="random"]:checked ~ .specify-control-container {
            display: none;
        }
        .setting-group input[type="radio"][value="specify"]:checked ~ .specify-control,
        .setting-group input[type="radio"][value="specify"]:checked ~ .specify-control-container {
            display: flex; /* Or appropriate display value */
        }
        .color-picker-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #ccc;
            border-radius: 0.375rem;
        }
        .color-picker-wrapper.is-disabled input[type="color"] {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .color-picker-wrapper.is-disabled::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            width: 80%;
            height: 2px;
            background-color: rgba(220, 38, 38, 0.6); /* red-600 with opacity */
            transform: translateY(-50%) rotate(-45deg);
            pointer-events: none;
            border-radius: 1px;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen">

    <!-- 上部パネル -->
    <header class="bg-white shadow-md p-2 flex items-center justify-between flex-shrink-0">
        <h1 class="text-lg font-bold text-gray-700" data-lang="app-title">ランダム文字配置メーカー</h1>
        <div class="flex items-center space-x-2">
            <button id="btn-image-output" class="btn btn-gray px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-image-output">画像出力</button>
            <button id="btn-help" class="btn btn-gray px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-help">操作説明</button>
            <span class="text-gray-300">|</span>
            <button id="btn-save-settings" class="btn btn-gray px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-save">設定を保存</button>
            <button id="btn-load-settings" class="btn btn-gray px-3 py-1.5 rounded-md text-sm font-semibold" data-lang="btn-load">設定を読込</button>
            <input type="file" id="settings-file-input" class="hidden" accept=".json">
            <span class="text-gray-300">|</span>
            <button id="btn-lang-switch" class="btn btn-gray px-3 py-1.5 rounded-md text-sm font-semibold w-24">English</button>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <div class="flex-grow flex p-4 gap-4 overflow-hidden">

        <!-- 左パネル -->
        <div class="w-1/3 max-w-lg flex-shrink-0 overflow-y-auto bg-white p-4 rounded-lg shadow-lg">
            
            <!-- 設定パネル (デフォルト) -->
            <div id="settings-panel">
                <div id="text-drop-area" class="drop-area w-full h-24 rounded-lg flex items-center justify-center text-gray-500 mb-1 cursor-pointer">
                    <span data-lang="text-drop-area">テキストファイルをここにドロップ</span>
                </div>
                <button id="delete-text-btn" class="text-xs text-red-500 hover:text-red-700 w-full text-right mb-2 hidden" data-lang="delete-text">テキストを削除</button>
                <input type="file" id="text-file-input" class="hidden" accept=".txt">
                <button id="generate-btn" class="btn bg-indigo-600 text-white w-full py-2 rounded-md font-bold hover:bg-indigo-700" data-lang="generate-btn">画像を作成</button>
                
                <!-- アコーディオン -->
                <div class="space-y-2 mt-4">
                    <!-- フィールド設定 -->
                    <div>
                        <button class="accordion-toggle w-full text-left font-semibold p-2 bg-gray-200 rounded-md" data-target="#field-settings">
                            <span data-lang="accordion-field">フィールド設定</span>
                        </button>
                        <div id="field-settings" class="accordion-content">
                            <div class="p-4">
                                <label class="block text-sm font-medium" data-lang="canvas-size">画面サイズ</label>
                                <div class="flex gap-2 mt-1">
                                    <input type="number" id="canvas-width" value="800" class="w-full p-1 border rounded-md realtime-update save-state">
                                    <span class="self-center">x</span>
                                    <input type="number" id="canvas-height" value="600" class="w-full p-1 border rounded-md realtime-update save-state">
                                </div>
                                <label class="block text-sm font-medium mt-2" data-lang="bg-color">背景色</label>
                                <div class="flex items-center gap-2">
                                    <input type="color" id="bg-color" value="#ffffff" class="w-full h-8 border rounded-md realtime-update save-state">
                                    <input type="range" id="bg-color-opacity" min="0" max="1" step="0.05" value="0" class="w-full mt-1 realtime-update save-state">
                                </div>
                                
                                <div id="bg-image-drop-area" class="drop-area w-full h-20 rounded-lg flex items-center justify-center text-gray-500 mt-2 mb-1 cursor-pointer">
                                    <span data-lang="bg-image-drop-area">背景画像をドロップ</span>
                                </div>
                                <button id="delete-bg-image-btn" class="text-xs text-red-500 hover:text-red-700 w-full text-right hidden" data-lang="delete-bg-image">背景画像を削除</button>
                                <input type="file" id="bg-image-input" class="hidden" accept="image/*">

                                <label class="block text-sm font-medium mt-2" data-lang="bg-opacity">背景画像の透過度</label>
                                <input type="range" id="bg-opacity" min="0" max="1" step="0.05" value="1" class="w-full mt-1 realtime-update save-state">
                                
                                <label class="block text-sm font-medium mt-2" data-lang="bg-scale">背景画像の拡大縮小</label>
                                <input type="range" id="bg-scale" min="0.1" max="3" step="0.1" value="1" class="w-full mt-1 realtime-update save-state">
                                <button id="reset-field-settings" class="btn bg-orange-500 text-white w-full py-1.5 rounded-md text-sm mt-4 hover:bg-orange-600" data-lang="reset-settings">設定をリセット</button>
                            </div>
                        </div>
                    </div>

                    <!-- ランダム処理の設定 -->
                    <div>
                        <button class="accordion-toggle w-full text-left font-semibold p-2 bg-gray-200 rounded-md" data-target="#random-settings">
                           <span data-lang="accordion-random">ランダム処理の設定</span>
                        </button>
                        <div id="random-settings" class="accordion-content">
                            <div class="p-4 space-y-3">
                                <!-- Reordered settings -->
                                <div>
                                    <label class="block text-sm font-medium" data-lang="font-size">フォントサイズ (最小 - 最大)</label>
                                    <div class="flex gap-2 mt-1 items-center">
                                        <input type="range" id="font-size-min" min="8" max="150" value="16" class="w-full save-state">
                                        <span id="font-size-min-val" class="text-xs w-8 text-center">16</span>
                                        <span>-</span>
                                        <input type="range" id="font-size-max" min="8" max="150" value="48" class="w-full save-state">
                                        <span id="font-size-max-val" class="text-xs w-8 text-center">48</span>
                                    </div>
                                </div>
                                <div class="setting-group">
                                    <label class="block text-sm font-medium" data-lang="text-opacity">文字の透過率</label>
                                    <div class="flex gap-4 text-sm mt-1">
                                        <label><input type="radio" name="text-opacity-mode" value="specify" checked class="save-state"> <span data-lang="mode-specify">指定</span></label>
                                        <label><input type="radio" name="text-opacity-mode" value="random" class="save-state"> <span data-lang="mode-random">ランダム</span></label>
                                    </div>
                                    <input type="range" id="text-opacity" min="0" max="1" step="0.05" value="1" class="specify-control hide-on-random w-full mt-1 save-state">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mt-2" data-lang="writing-mode">縦書きの比率</label>
                                    <input type="range" id="vertical-ratio" min="0" max="100" value="50" class="w-full mt-1 save-state">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mt-2" data-lang="text-order">文字の順序</label>
                                    <div class="flex justify-around text-sm mt-1">
                                        <label><input type="radio" name="text-order" value="top" class="save-state"> <span data-lang="order-top">上から</span></label>
                                        <label><input type="radio" name="text-order" value="bottom" class="save-state"> <span data-lang="order-bottom">下から</span></label>
                                        <label><input type="radio" name="text-order" value="random" checked class="save-state"> <span data-lang="order-random">ランダム</span></label>
                                    </div>
                                </div>
                                <div class="text-sm mt-2">
                                    <label class="flex items-center"><input type="checkbox" id="wrap-text" class="mr-2 save-state"> <span data-lang="wrap-text">テキストを画像内で折り返す</span></label>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mt-2" data-lang="text-placement">画面内の文章の配置</label>
                                     <div class="flex justify-around text-sm mt-1">
                                        <label><input type="radio" name="text-placement" value="random" class="save-state"> <span data-lang="placement-random">ランダム</span></label>
                                        <label><input type="radio" name="text-placement" value="soft-avoid" checked class="save-state"> <span data-lang="placement-soft">ソフト</span></label>
                                        <label><input type="radio" name="text-placement" value="avoid-overlap" class="save-state"> <span data-lang="placement-avoid">重複を避ける</span></label>
                                    </div>
                                </div>

                                <!-- Original settings -->
                                <div class="setting-group pt-2 border-t mt-3">
                                    <label class="block text-sm font-medium" data-lang="font-color">文字色</label>
                                    <div class="flex gap-4 text-sm mt-1 items-center">
                                        <label><input type="radio" name="font-color-mode" value="random" checked class="save-state"> <span data-lang="mode-random">ランダム</span></label>
                                        <label class="flex items-center">
                                            <input type="radio" name="font-color-mode" value="specify" class="save-state"> 
                                            <span class="ml-1" data-lang="mode-specify">指定</span>
                                            <input type="number" id="font-color-count" value="1" min="1" max="5" class="w-12 ml-2 p-0.5 border rounded-md text-center specify-control save-state">
                                        </label>
                                    </div>
                                    <div id="font-color-pickers" class="specify-control-container flex gap-2 mt-2 flex-wrap"></div>
                                </div>
                                <div class="space-y-2 text-sm">
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-bold">太字</span>
                                        <div class="flex gap-3">
                                            <label class="flex items-center"><input type="radio" name="font-bold-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random-short">ランダム</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-bold-mode" value="on" class="save-state"> <span class="ml-1">On</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-bold-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label>
                                        </div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-italic">斜体</span>
                                        <div class="flex gap-3">
                                            <label class="flex items-center"><input type="radio" name="font-italic-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random-short">ランダム</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-italic-mode" value="on" class="save-state"> <span class="ml-1">On</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-italic-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label>
                                        </div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-shadow">影</span>
                                        <div class="flex gap-3">
                                            <label class="flex items-center"><input type="radio" name="font-shadow-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random-short">ランダム</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-shadow-mode" value="on" class="save-state"> <span class="ml-1">On</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-shadow-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label>
                                        </div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span data-lang="font-stroke">縁取り</span>
                                        <div class="flex gap-3">
                                            <label class="flex items-center"><input type="radio" name="font-stroke-mode" value="random" checked class="save-state"> <span class="ml-1" data-lang="mode-random-short">ランダム</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-stroke-mode" value="on" class="save-state"> <span class="ml-1">On</span></label>
                                            <label class="flex items-center"><input type="radio" name="font-stroke-mode" value="off" class="save-state"> <span class="ml-1">Off</span></label>
                                        </div>
                                    </div>
                                </div>
                                <div class="setting-group">
                                    <label class="block text-sm font-medium" data-lang="font-stroke-color">縁取りの色</label>
                                    <div class="flex gap-4 text-sm mt-1 items-center">
                                        <label><input type="radio" name="font-stroke-color-mode" value="random" checked class="save-state"> <span data-lang="mode-random">ランダム</span></label>
                                        <label class="flex items-center">
                                            <input type="radio" name="font-stroke-color-mode" value="specify" class="save-state">
                                            <span class="ml-1" data-lang="mode-specify">指定</span>
                                            <input type="number" id="font-stroke-color-count" value="1" min="1" max="5" class="w-12 ml-2 p-0.5 border rounded-md text-center specify-control save-state">
                                        </label>
                                    </div>
                                    <div id="font-stroke-color-pickers" class="specify-control-container flex gap-2 mt-2 flex-wrap"></div>
                                </div>
                                <button id="reset-random-settings" class="btn bg-orange-500 text-white w-full py-1.5 rounded-md text-sm mt-4 hover:bg-orange-600" data-lang="reset-settings">設定をリセット</button>
                            </div>
                        </div>
                    </div>

                    <!-- フォント設定 -->
                    <div>
                        <button class="accordion-toggle w-full text-left font-semibold p-2 bg-gray-200 rounded-md" data-target="#font-settings">
                           <span data-lang="accordion-font">フォント設定（使用選択）</span>
                        </button>
                        <div id="font-settings" class="accordion-content">
                           <div class="p-4 space-y-2">
                                <div class="flex gap-2">
                                    <button id="font-select-all" class="btn bg-gray-200 text-gray-700 text-xs py-1 px-2 rounded-md w-full">全てON</button>
                                    <button id="font-deselect-all" class="btn bg-gray-200 text-gray-700 text-xs py-1 px-2 rounded-md w-full">全てOFF</button>
                                </div>
                                <div id="font-selection-list" class="mt-2"></div>
                           </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 画像出力パネル (非表示) -->
            <div id="image-output-panel" class="hidden">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold" data-lang="panel-title-output">画像出力</h2>
                    <button class="panel-back-btn btn text-sm text-indigo-600 border border-gray-300 px-2 py-1 rounded-md hover:bg-gray-100" data-lang="btn-back">戻る</button>
                </div>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium" data-lang="output-format">フォーマット</label>
                        <select id="output-format" class="w-full p-2 border rounded-md mt-1">
                            <option value="png">PNG</option>
                            <option value="jpeg">JPEG</option>
                        </select>
                    </div>
                    <button id="download-btn" class="btn bg-indigo-600 text-white w-full py-2 rounded-md font-bold hover:bg-indigo-700" data-lang="btn-download">ダウンロード</button>
                </div>
            </div>

            <!-- 操作説明パネル (非表示) -->
            <div id="help-panel" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold" data-lang="panel-title-help">操作説明</h2>
                    <button class="panel-back-btn btn text-sm text-indigo-600 border border-gray-300 px-2 py-1 rounded-md hover:bg-gray-100" data-lang="btn-back">戻る</button>
                </div>
                 <div class="text-sm space-y-3" data-lang-html="help-content">
                 </div>
            </div>

        </div>

        <!-- 右パネル (キャンバス) -->
        <div class="flex-grow bg-white rounded-lg shadow-lg flex items-center justify-center p-2 overflow-auto relative">
            <canvas id="main-canvas" class="border"></canvas>
            <div id="notification-area" class="absolute bottom-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-lg hidden" role="alert"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM要素の取得 ---
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            
            const textDropArea = document.getElementById('text-drop-area');
            const textFileInput = document.getElementById('text-file-input');
            const deleteTextBtn = document.getElementById('delete-text-btn');
            const bgImageDropArea = document.getElementById('bg-image-drop-area');
            const bgImageInput = document.getElementById('bg-image-input');
            const deleteBgImageBtn = document.getElementById('delete-bg-image-btn');
            const generateBtn = document.getElementById('generate-btn');
            const downloadBtn = document.getElementById('download-btn');
            const notificationArea = document.getElementById('notification-area');
            const saveSettingsBtn = document.getElementById('btn-save-settings');
            const loadSettingsBtn = document.getElementById('btn-load-settings');
            const settingsFileInput = document.getElementById('settings-file-input');
            const resetFieldSettingsBtn = document.getElementById('reset-field-settings');
            const resetRandomSettingsBtn = document.getElementById('reset-random-settings');
            const fontSelectAllBtn = document.getElementById('font-select-all');
            const fontDeselectAllBtn = document.getElementById('font-deselect-all');

            // --- 状態管理 ---
            let textLines = [];
            let bgImage = null;
            let lastGeneratedLayout = [];
            const fontList = [
                { name: 'Noto Sans JP', value: 'Noto Sans JP' },
                { name: 'Zen Kaku Gothic New', value: 'Zen Kaku Gothic New' },
                { name: 'M PLUS Rounded 1c', value: 'M PLUS Rounded 1c' },
                { name: 'BIZ UDPGothic', value: 'BIZ UDPGothic' },
                { name: 'Kosugi Maru', value: 'Kosugi Maru' },
                { name: 'さわらびゴシック', value: 'Sawarabi Gothic' },
                { name: 'Shippori Mincho', value: 'Shippori Mincho' },
                { name: 'Hina Mincho', value: 'Hina Mincho' },
                { name: 'Yuji Syuku', value: 'Yuji Syuku' },
                { name: 'Kaisei Opti', value: 'Kaisei Opti' },
                { name: 'Kaisei Decol', value: 'Kaisei Decol' },
                { name: 'Kiwi Maru', value: 'Kiwi Maru' },
                { name: 'Yusei Magic', value: 'Yusei Magic' },
                { name: 'DotGothic16', value: 'DotGothic16' },
                { name: 'Dela Gothic One', value: 'Dela Gothic One' },
                { name: 'Mochiy Pop One', value: 'Mochiy Pop One' },
                { name: 'Potta One', value: 'Potta One' },
                { name: 'RocknRoll One', value: 'RocknRoll One' },
            ];

            // --- UI翻訳データ ---
            const translations = {
                'ja': {
                    'app-title': 'ランダム文字配置メーカー',
                    'btn-image-output': '画像出力',
                    'btn-help': '操作説明',
                    'btn-save': '設定を保存',
                    'btn-load': '設定を読込',
                    'lang-switch': 'English',
                    'text-drop-area': 'テキストファイルをここにドロップ',
                    'delete-text': 'テキストを削除',
                    'delete-bg-image': '背景画像を削除',
                    'generate-btn': '画像を作成',
                    'accordion-field': 'フィールド設定',
                    'accordion-font': 'フォント設定（使用選択）',
                    'canvas-size': '画面サイズ',
                    'bg-color': '背景色',
                    'bg-image-drop-area': '背景画像をドロップ',
                    'bg-opacity': '背景画像の透過度',
                    'bg-scale': '背景画像の拡大縮小',
                    'accordion-random': 'ランダム処理の設定',
                    'mode-specify': '指定',
                    'mode-random': 'ランダム',
                    'mode-random-short': 'ランダム',
                    'font-color': '文字色',
                    'font-bold': '太字',
                    'font-italic': '斜体',
                    'font-shadow': '影',
                    'font-stroke': '縁取り',
                    'font-stroke-color': '縁取りの色',
                    'font-size': 'フォントサイズ (最小 - 最大)',
                    'text-opacity': '文字の透過率',
                    'writing-mode': '縦書きの比率',
                    'text-order': '文字の順序',
                    'wrap-text': 'テキストを画像内で折り返す',
                    'order-top': '上から',
                    'order-bottom': '下から',
                    'order-random': 'ランダム',
                    'text-placement': '画面内の文章の配置',
                    'placement-random': 'ランダム',
                    'placement-soft': 'ソフト',
                    'placement-avoid': '重複を避ける',
                    'panel-title-output': '画像出力',
                    'btn-back': '戻る',
                    'output-format': 'フォーマット',
                    'btn-download': 'ダウンロード',
                    'panel-title-help': '操作説明',
                    'initial-text': 'ここに画像が生成されます',
                    'unplaced-text': '{count}個の文章を配置できませんでした。',
                    'reset-settings': '設定をリセット',
                    'help-content': `
                        <p><b>1. テキストを用意する</b></p>
                        <p>左上のエリアにテキストファイル (.txt) をドラッグ＆ドロップします(メモ帳のファイル)。テキストファイル内の改行と改行の間の文字が、一つの文章として認識されます。</p>
                        <p><b>2. 設定を調整する</b></p>
                        <p>各アコーディオンを開き、背景や文字のスタイル、ランダム化のルールを自由に調整できます。</p>
                        <p><b>3. 画像を生成する</b></p>
                        <p>「画像を作成」ボタンを押すと、右側のフィールドに文章がランダムに配置されます。「文章を配置できませんでした」と表示された場合は、<b>[画面内の文章の配置]</b>を「ランダム」か「ソフト」に変更するか、<b>[フォントサイズ]</b>を小さくしてみてください。</p>
                        <p><b>4. 設定を保存・呼び出しする</b></p>
                        <p>ヘッダーの「設定を保存」ボタンで、現在の設定をファイルとしてダウンロードできます。「設定を読込」で、そのファイルを読み込んで設定を復元できます。</p>
                        <p><b>5. 画像を出力する</b></p>
                        <p>「画像出力」ボタンでパネルを切り替え、好きなフォーマットで画像をダウンロードできます。</p>
                    `
                },
                'en': {
                    'app-title': 'Random Text Placer',
                    'btn-image-output': 'Export Image',
                    'btn-help': 'Help',
                    'btn-save': 'Save Settings',
                    'btn-load': 'Load Settings',
                    'lang-switch': '日本語',
                    'text-drop-area': 'Drop text file here',
                    'delete-text': 'Delete text',
                    'delete-bg-image': 'Delete background image',
                    'generate-btn': 'Generate Image',
                    'accordion-field': 'Field Settings',
                    'accordion-font': 'Font Settings (Select to use)',
                    'canvas-size': 'Canvas Size',
                    'bg-color': 'Background Color',
                    'bg-image-drop-area': 'Drop background image here',
                    'bg-opacity': 'Background Image Opacity',
                    'bg-scale': 'Background Image Scale',
                    'accordion-random': 'Randomization Settings',
                    'mode-specify': 'Specify',
                    'mode-random': 'Random',
                    'mode-random-short': 'Random',
                    'font-color': 'Font Color',
                    'font-bold': 'Bold',
                    'font-italic': 'Italic',
                    'font-shadow': 'Shadow',
                    'font-stroke': 'Stroke',
                    'font-stroke-color': 'Stroke Color',
                    'font-size': 'Font Size (Min - Max)',
                    'text-opacity': 'Text Opacity',
                    'writing-mode': 'Vertical Text Ratio',
                    'text-order': 'Text Order',
                    'wrap-text': 'Wrap text within image',
                    'order-top': 'Top to Bottom',
                    'order-bottom': 'Bottom to Top',
                    'order-random': 'Random',
                    'text-placement': 'Sentence Placement',
                    'placement-random': 'Random',
                    'placement-soft': 'Soft',
                    'placement-avoid': 'Avoid Overlap',
                    'panel-title-output': 'Export Image',
                    'btn-back': 'Back',
                    'output-format': 'Format',
                    'btn-download': 'Download',
                    'panel-title-help': 'Instructions',
                    'initial-text': 'Image will be generated here',
                    'unplaced-text': 'Could not place {count} sentences.',
                    'reset-settings': 'Reset Settings',
                    'help-content': `
                        <p><b>1. Prepare Your Text</b></p>
                        <p>Drag and drop a text file (.txt) into the area on the top left. The text between line breaks will be treated as a single sentence.</p>
                        <p><b>2. Adjust Settings</b></p>
                        <p>Open the accordions to freely customize the background, text styles, and randomization rules.</p>
                        <p><b>3. Generate the Image</b></p>
                        <p>Press the "Generate Image" button to randomly place the sentences on the canvas. If you see a "Could not place sentences" message, try changing the <b>[Sentence Placement]</b> mode to "Random" or "Soft", or reduce the <b>[Font Size]</b>.</p>
                        <p><b>4. Save & Load Settings</b></p>
                        <p>You can download the current settings as a file using the "Save Settings" button in the header. Use "Load Settings" to restore them from a file.</p>
                        <p><b>5. Export Your Image</b></p>
                        <p>Click the "Export Image" button to switch panels and download the image in your desired format.</p>
                    `
                }
            };
            let currentLang = 'ja';

            // --- UI初期化 ---
            function populateFontList() {
                const container = document.getElementById('font-selection-list');
                container.innerHTML = ''; // Clear existing
                fontList.forEach(font => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between text-sm pb-2 mb-2 border-b border-gray-200';
                    div.innerHTML = `
                        <div class="flex items-center">
                            <input type="checkbox" id="font-check-${font.value.replace(/\s/g, '')}" name="font-choice" value="${font.value}" checked class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 save-state">
                            <label for="font-check-${font.value.replace(/\s/g, '')}" class="ml-2">${font.name}</label>
                        </div>
                        <span style="font-family: '${font.value}', sans-serif; font-size: 20px;">M邪もジャ3！？</span>
                    `;
                    container.appendChild(div);
                });
            }

            // --- イベントリスナー ---

            // アコーディオン
            document.querySelectorAll('.accordion-toggle').forEach(button => {
                button.addEventListener('click', () => {
                    const content = document.querySelector(button.dataset.target);
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                    }
                });
            });

            // フォントサイズスライダーの値表示
            const fontSizeMin = document.getElementById('font-size-min');
            const fontSizeMax = document.getElementById('font-size-max');
            const fontSizeMinVal = document.getElementById('font-size-min-val');
            const fontSizeMaxVal = document.getElementById('font-size-max-val');
            fontSizeMin.addEventListener('input', () => fontSizeMinVal.textContent = fontSizeMin.value);
            fontSizeMax.addEventListener('input', () => fontSizeMaxVal.textContent = fontSizeMax.value);

            // ファイルドロップ共通処理
            const setupDropArea = (area, input, onFileLoad) => {
                area.addEventListener('click', () => input.click());
                area.addEventListener('dragover', (e) => { e.preventDefault(); area.classList.add('dragover'); });
                area.addEventListener('dragleave', () => area.classList.remove('dragover'));
                area.addEventListener('drop', (e) => {
                    e.preventDefault();
                    area.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file) onFileLoad(file);
                });
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) onFileLoad(file);
                });
            };

            // テキストファイルのドロップ
            setupDropArea(textDropArea, textFileInput, (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    textLines = e.target.result.split(/\r\n|\n/).filter(line => line.trim() !== '');
                    textDropArea.querySelector('span').textContent = file.name;
                    deleteTextBtn.classList.remove('hidden');
                };
                reader.readAsText(file);
            });
            
            deleteTextBtn.addEventListener('click', () => {
                textLines = [];
                textFileInput.value = '';
                textDropArea.querySelector('span').textContent = translations[currentLang]['text-drop-area'];
                deleteTextBtn.classList.add('hidden');
                generateAndRedraw();
            });

            // 背景画像のドロップ
            setupDropArea(bgImageDropArea, bgImageInput, (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    bgImage = new Image();
                    bgImage.onload = () => { 
                        bgImageDropArea.querySelector('span').textContent = file.name; 
                        deleteBgImageBtn.classList.remove('hidden');
                        redrawCanvas();
                    };
                    bgImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });

            deleteBgImageBtn.addEventListener('click', () => {
                bgImage = null;
                bgImageInput.value = '';
                bgImageDropArea.querySelector('span').textContent = translations[currentLang]['bg-image-drop-area'];
                deleteBgImageBtn.classList.add('hidden');
                redrawCanvas();
            });
            
            // パネル切り替え
            const panels = {
                settings: document.getElementById('settings-panel'),
                output: document.getElementById('image-output-panel'),
                help: document.getElementById('help-panel')
            };
            const headerBtns = {
                output: document.getElementById('btn-image-output'),
                help: document.getElementById('btn-help')
            };

            const switchPanel = (panelName) => {
                Object.values(panels).forEach(p => p.classList.add('hidden'));
                if(panels[panelName]) panels[panelName].classList.remove('hidden');
                headerBtns.output.classList.remove('active', 'active-purple');
                headerBtns.help.classList.remove('active', 'active-green');
                if (panelName === 'output') headerBtns.output.classList.add('active', 'active-purple');
                else if (panelName === 'help') headerBtns.help.classList.add('active', 'active-green');
            };

            headerBtns.output.addEventListener('click', () => switchPanel('output'));
            headerBtns.help.addEventListener('click', () => switchPanel('help'));
            document.querySelectorAll('.panel-back-btn').forEach(btn => btn.addEventListener('click', () => switchPanel('settings')));

            // 言語切り替え
            const langSwitchBtn = document.getElementById('btn-lang-switch');
            const switchLanguage = (lang) => {
                currentLang = lang;
                document.documentElement.lang = lang;
                const translationData = translations[lang];
                document.querySelectorAll('[data-lang]').forEach(el => {
                    const key = el.dataset.lang;
                    if (translationData[key]) el.textContent = translationData[key];
                });
                 document.querySelectorAll('[data-lang-html]').forEach(el => {
                    const key = el.dataset.langHtml;
                    if (translationData[key]) el.innerHTML = translationData[key];
                });
                langSwitchBtn.textContent = translationData['lang-switch'];
            };

            langSwitchBtn.addEventListener('click', () => switchLanguage(currentLang === 'ja' ? 'en' : 'ja'));

            // リアルタイム更新
            document.querySelectorAll('.realtime-update').forEach(el => {
                el.addEventListener('input', () => redrawCanvas());
            });
            
            generateBtn.addEventListener('click', generateAndRedraw);

            function generateAndRedraw() {
                notificationArea.classList.add('hidden');
                lastGeneratedLayout = []; // Clear previous layout
                
                const settings = getSettings();
                const activeFonts = getActiveFonts();

                let linesToDraw = [...textLines];
                if (linesToDraw.length === 0) {
                    redrawCanvas();
                    return;
                }
                if (settings.textOrder === 'bottom') linesToDraw.reverse();
                if (settings.textOrder === 'random') linesToDraw.sort(() => Math.random() - 0.5);
                
                // New: Sort by length descending
                linesToDraw.sort((a, b) => b.length - a.length);
                const maxLength = linesToDraw.length > 0 ? linesToDraw[0].length : 0;

                const placedRects = [];
                let placedLinesCount = 0;

                linesToDraw.forEach(line => {
                    const lineStyle = {};
                    lineStyle.fontFamily = activeFonts[Math.floor(Math.random() * activeFonts.length)];
                    lineStyle.fontColor = settings.fontColorMode === 'random' ? getRandomColor() : (settings.fontColors.length > 0 ? settings.fontColors[Math.floor(Math.random() * settings.fontColors.length)] : '#000000');
                    lineStyle.fontStrokeColor = settings.fontStrokeColorMode === 'random' ? getRandomColor() : (settings.fontStrokeColors.length > 0 ? settings.fontStrokeColors[Math.floor(Math.random() * settings.fontStrokeColors.length)] : '#FFFFFF');
                    
                    const getBoolStyle = (mode) => (mode === 'on') ? true : (mode === 'off') ? false : Math.random() < 0.5;
                    lineStyle.fontBold = getBoolStyle(settings.fontBoldMode);
                    lineStyle.fontItalic = getBoolStyle(settings.fontItalicMode);
                    lineStyle.fontShadow = getBoolStyle(settings.fontShadowMode);
                    lineStyle.fontStroke = getBoolStyle(settings.fontStrokeMode);
                    
                    lineStyle.opacity = settings.textOpacityMode === 'random' ? Math.random() : settings.textOpacity;

                    // New: Bias font size based on length
                    const lengthRatio = maxLength > 0 ? line.length / maxLength : 0;
                    const sizeRange = settings.fontSizeMax - settings.fontSizeMin;
                    const reduction = lengthRatio * sizeRange * 0.5; // Bias factor: 0.5
                    const effectiveMax = Math.max(settings.fontSizeMin, settings.fontSizeMax - reduction);
                    const fontSize = Math.random() * (effectiveMax - settings.fontSizeMin) + settings.fontSizeMin;

                    const isVertical = Math.random() * 100 < settings.verticalRatio;

                    // 位置決め
                    let bestPosition = null;
                    let minOverlap = Infinity;

                    let maxAttempts;
                    if (settings.textPlacement === 'avoid-overlap') maxAttempts = 100;
                    else if (settings.textPlacement === 'soft-avoid') maxAttempts = 50;
                    else maxAttempts = 1;

                    for (let i = 0; i < maxAttempts; i++) {
                        let currentRect, currentX, currentY;
                        
                        ctx.font = `${lineStyle.fontItalic ? 'italic ' : ''}${lineStyle.fontBold ? 'bold ' : ''} ${fontSize}px "${lineStyle.fontFamily}"`;
                        
                        let textBlock;

                        if (isVertical) {
                            textBlock = getVerticalTextBlock(line, fontSize, settings.height, settings.wrapText);
                        } else {
                            textBlock = getHorizontalTextBlock(ctx, line, fontSize, settings.width, settings.wrapText);
                        }

                        const shadowOffset = lineStyle.fontShadow ? 5 : 0;
                        const textWidth = textBlock.width + shadowOffset;
                        const textHeight = textBlock.height + shadowOffset;
                        
                        currentX = Math.random() * (settings.width - textWidth);
                        currentY = Math.random() * (settings.height - textHeight);
                        
                        currentRect = { x: currentX, y: currentY, width: textWidth, height: textHeight };

                        if (settings.textPlacement === 'soft-avoid') {
                            let currentOverlap = 0;
                            for (const placedRect of placedRects) {
                                currentOverlap += calculateOverlapArea(currentRect, placedRect);
                            }
                            if (currentOverlap < minOverlap) {
                                minOverlap = currentOverlap;
                                bestPosition = { rect: currentRect, x: currentX, y: currentY, textBlock: textBlock };
                            }
                            if (minOverlap === 0) break;
                        } else { // 'random' or 'avoid-overlap'
                            if (!isOverlapping(currentRect, placedRects)) {
                                bestPosition = { rect: currentRect, x: currentX, y: currentY, textBlock: textBlock };
                                break;
                            }
                            if (settings.textPlacement === 'random') {
                                bestPosition = { rect: currentRect, x: currentX, y: currentY, textBlock: textBlock };
                                break;
                            }
                        }
                    }

                    if (bestPosition) {
                        placedLinesCount++;
                        lastGeneratedLayout.push({
                            line: line,
                            style: lineStyle,
                            fontSize: fontSize,
                            isVertical: isVertical,
                            position: bestPosition
                        });
                        placedRects.push(bestPosition.rect);
                    }
                });

                const unplacedCount = linesToDraw.length - placedLinesCount;
                if (unplacedCount > 0 && settings.textPlacement === 'avoid-overlap') {
                    const message = translations[currentLang]['unplaced-text'].replace('{count}', unplacedCount);
                    notificationArea.textContent = message;
                    notificationArea.classList.remove('hidden');
                }

                redrawCanvas();
            }

            function redrawCanvas() {
                const settings = getSettings();
                canvas.width = settings.width;
                canvas.height = settings.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (bgImage) {
                    ctx.globalAlpha = settings.bgOpacity;
                    const w = bgImage.width * settings.bgScale;
                    const h = bgImage.height * settings.bgScale;
                    ctx.drawImage(bgImage, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
                }
                
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = hexToRgba(settings.bgColor, settings.bgColorOpacity);
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (lastGeneratedLayout.length === 0 && textLines.length === 0) {
                    ctx.font = "24px 'Noto Sans JP'";
                    ctx.fillStyle = "#AAAAAA";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(translations[currentLang]['initial-text'], canvas.width / 2, canvas.height / 2);
                    return;
                }

                lastGeneratedLayout.forEach(item => {
                    const { style, fontSize, isVertical, position } = item;
                    
                    ctx.globalAlpha = style.opacity;
                    let fontStyleStr = `${style.fontItalic ? 'italic ' : ''}${style.fontBold ? 'bold ' : ''}`;
                    ctx.font = `${fontStyleStr} ${fontSize}px "${style.fontFamily}"`;
                    ctx.fillStyle = style.fontColor;
                    ctx.strokeStyle = style.fontStrokeColor;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = style.fontShadow ? 'rgba(0, 0, 0, 0.5)' : 'transparent';
                    if (style.fontShadow) {
                        ctx.shadowBlur = 5;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                    } else {
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }

                    if (isVertical) {
                        drawVerticalText(position.textBlock.lines, position.x, position.y, fontSize, style);
                    } else {
                        position.textBlock.lines.forEach((wrappedLine, index) => {
                            const lineY = position.y + fontSize + (index * fontSize);
                            if (style.fontStroke) ctx.strokeText(wrappedLine, position.x, lineY);
                            ctx.fillText(wrappedLine, position.x, lineY);
                        });
                    }
                });
                ctx.globalAlpha = 1.0;
            }

            function getSettings() {
                const fontColorPickers = document.querySelectorAll('#font-color-pickers input[type="color"]:not(:disabled)');
                const fontStrokeColorPickers = document.querySelectorAll('#font-stroke-color-pickers input[type="color"]:not(:disabled)');
                return {
                    width: parseInt(document.getElementById('canvas-width').value, 10),
                    height: parseInt(document.getElementById('canvas-height').value, 10),
                    bgColor: document.getElementById('bg-color').value,
                    bgColorOpacity: parseFloat(document.getElementById('bg-color-opacity').value),
                    bgOpacity: parseFloat(document.getElementById('bg-opacity').value),
                    bgScale: parseFloat(document.getElementById('bg-scale').value, 10),
                    fontColorMode: document.querySelector('input[name="font-color-mode"]:checked').value,
                    fontStrokeColorMode: document.querySelector('input[name="font-stroke-color-mode"]:checked').value,
                    fontBoldMode: document.querySelector('input[name="font-bold-mode"]:checked').value,
                    fontItalicMode: document.querySelector('input[name="font-italic-mode"]:checked').value,
                    fontShadowMode: document.querySelector('input[name="font-shadow-mode"]:checked').value,
                    fontStrokeMode: document.querySelector('input[name="font-stroke-mode"]:checked').value,
                    textOpacityMode: document.querySelector('input[name="text-opacity-mode"]:checked').value,
                    wrapText: document.getElementById('wrap-text').checked,
                    fontColors: Array.from(fontColorPickers).map(picker => picker.value),
                    fontStrokeColors: Array.from(fontStrokeColorPickers).map(picker => picker.value),
                    fontColorCount: parseInt(document.getElementById('font-color-count').value, 10),
                    fontStrokeColorCount: parseInt(document.getElementById('font-stroke-color-count').value, 10),
                    textOpacity: parseFloat(document.getElementById('text-opacity').value),
                    fontSizeMin: parseInt(document.getElementById('font-size-min').value, 10),
                    fontSizeMax: parseInt(document.getElementById('font-size-max').value, 10),
                    verticalRatio: parseInt(document.getElementById('vertical-ratio').value, 10),
                    textOrder: document.querySelector('input[name="text-order"]:checked').value,
                    textPlacement: document.querySelector('input[name="text-placement"]:checked').value,
                };
            }
            
            function getActiveFonts() {
                const checkedFonts = Array.from(document.querySelectorAll('input[name="font-choice"]:checked')).map(cb => cb.value);
                return checkedFonts.length > 0 ? checkedFonts : ['Noto Sans JP'];
            }
            
            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function calculateOverlapArea(rect1, rect2) {
                const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
                const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
                return x_overlap * y_overlap;
            }

            function getRandomColor() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }

            function getHorizontalTextBlock(ctx, text, fontSize, maxWidth, wrap) {
                let lines;
                if(wrap) {
                    const words = text.split('');
                    lines = [];
                    let currentLine = '';
                    for (let i = 0; i < words.length; i++) {
                        const testLine = currentLine + words[i];
                        if (ctx.measureText(testLine).width > maxWidth && i > 0) {
                            lines.push(currentLine);
                            currentLine = words[i];
                        } else {
                            currentLine = testLine;
                        }
                    }
                    lines.push(currentLine);
                } else {
                    lines = [text];
                }
                const width = Math.max(...lines.map(l => ctx.measureText(l).width));
                const height = lines.length * fontSize;
                return { lines, width, height };
            }

            function getVerticalTextBlock(text, fontSize, maxHeight, wrap) {
                let columns;
                if(wrap && text.length * fontSize > maxHeight) {
                    const splitPoint = Math.ceil(text.length / 2);
                    columns = [text.substring(0, splitPoint), text.substring(splitPoint)];
                } else {
                    columns = [text];
                }
                const width = columns.length * fontSize;
                const height = Math.max(...columns.map(c => c.length * fontSize));
                return { lines: columns, width, height };
            }

            function drawVerticalText(columns, x, y, fontSize, lineStyle) {
                const charsToRotate = ['ー', '…', '(', ')', '（', '）', '[', ']', '［', '］', '{', '}', '｛', '｝', '~', '～'];
                const originalAlign = ctx.textAlign;
                const originalBaseline = ctx.textBaseline;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                columns.forEach((text, colIndex) => {
                    const colX = x + (columns.length - 1 - colIndex) * fontSize;
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        const cellCenterX = colX + fontSize / 2;
                        const cellCenterY = y + (i * fontSize) + (fontSize / 2);
                        if (charsToRotate.includes(char)) {
                            ctx.save();
                            ctx.translate(cellCenterX, cellCenterY);
                            ctx.rotate(Math.PI / 2);
                            if (lineStyle.fontStroke) ctx.strokeText(char, 0, 0);
                            ctx.fillText(char, 0, 0);
                            ctx.restore();
                        } else {
                            if (lineStyle.fontStroke) ctx.strokeText(char, cellCenterX, cellCenterY);
                            ctx.fillText(char, cellCenterX, cellCenterY);
                        }
                    }
                });
                
                ctx.textAlign = originalAlign;
                ctx.textBaseline = originalBaseline;
            }

            function isOverlapping(rect1, rects) {
                for (const rect2 of rects) {
                    if (!(rect1.x > rect2.x + rect2.width || rect1.x + rect1.width < rect2.x || rect1.y > rect2.y + rect2.height || rect1.y + rect1.height < rect2.y)) return true;
                }
                return false;
            }

            // ダウンロード処理
            downloadBtn.addEventListener('click', () => {
                const format = document.getElementById('output-format').value;
                const link = document.createElement('a');
                link.download = `random-text-art.${format}`;
                link.href = canvas.toDataURL(`image/${format}`, 1.0);
                link.click();
            });

            // カラーピッカーUIの管理
            function setupColorPickers(type) {
                const countInput = document.getElementById(`${type}-color-count`);
                const modeRadios = document.querySelectorAll(`input[name="${type}-color-mode"]`);
                const container = document.getElementById(`${type}-color-pickers`);
                const defaultColors = type === 'font' ? ['#000000', '#FF0000', '#0000FF', '#008000', '#FFFF00'] : ['#FFFFFF', '#000000', '#FF0000', '#0000FF', '#008000'];

                // Create 5 pickers initially and permanently
                for (let i = 0; i < 5; i++) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'color-picker-wrapper relative';
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = defaultColors[i] || defaultColors[0];
                    colorInput.classList.add('save-state');
                    colorInput.id = `${type}-color-${i}`;
                    wrapper.appendChild(colorInput);
                    container.appendChild(wrapper);
                }

                function updatePickerStates() {
                    const count = parseInt(countInput.value, 10);
                    const wrappers = container.querySelectorAll('.color-picker-wrapper');
                    wrappers.forEach((wrapper, i) => {
                        const picker = wrapper.querySelector('input[type="color"]');
                        if (i >= count) {
                            picker.disabled = true;
                            wrapper.classList.add('is-disabled');
                        } else {
                            picker.disabled = false;
                            wrapper.classList.remove('is-disabled');
                        }
                    });
                }

                countInput.addEventListener('input', () => {
                    updatePickerStates();
                    saveStateToLocalStorage();
                });
                modeRadios.forEach(radio => radio.addEventListener('change', () => {
                   const container = document.getElementById(`${type}-color-pickers`);
                   const countEl = document.getElementById(`${type}-color-count`);
                   if(document.querySelector(`input[name="${type}-color-mode"]:checked`).value === 'specify'){
                       container.style.display = 'flex';
                       countEl.style.display = 'flex';
                   } else {
                       container.style.display = 'none';
                       countEl.style.display = 'none';
                   }
                }));
                
                // Make updatePickerStates accessible for loadSettings
                container.updateStates = updatePickerStates;
                updatePickerStates(); // Initial state
            }
            
            const settingsKey = 'randomTextPlacerSettings';

            function saveStateToLocalStorage() {
                const settings = {};
                document.querySelectorAll('.save-state').forEach(el => {
                    if (el.type === 'radio') {
                        if (el.checked) {
                            settings[el.name] = el.value;
                        }
                    } else if (el.type === 'checkbox') {
                        settings[el.id] = el.checked;
                    } else {
                        settings[el.id] = el.value;
                    }
                });
                // Save color picker values
                settings.fontColorPickers = Array.from(document.querySelectorAll('#font-color-pickers input')).map(el => el.value);
                settings.fontStrokeColorPickers = Array.from(document.querySelectorAll('#font-stroke-color-pickers input')).map(el => el.value);
                
                localStorage.setItem(settingsKey, JSON.stringify(settings));
            }

            function applySettings(settings) {
                 // Apply all other settings
                 Object.keys(settings).forEach(key => {
                    if (key === 'fontColorPickers' || key === 'fontStrokeColorPickers') return;
                    
                    const el = document.getElementById(key);
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = settings[key];
                        } else {
                            el.value = settings[key];
                        }
                        if (el.type === 'range') {
                            el.dispatchEvent(new Event('input'));
                        }
                    } else {
                        const radioGroup = document.querySelectorAll(`input[name="${key}"]`);
                        if (radioGroup.length > 0) {
                            radioGroup.forEach(radio => {
                                if (radio.value === settings[key]) {
                                    radio.checked = true;
                                }
                            });
                        }
                    }
                });
                
                // Now that pickers exist, set their values
                if (settings.fontColorPickers) {
                    const pickers = document.querySelectorAll('#font-color-pickers input');
                    settings.fontColorPickers.forEach((color, i) => {
                        if(pickers[i]) pickers[i].value = color;
                    });
                }
                 if (settings.fontStrokeColorPickers) {
                    const pickers = document.querySelectorAll('#font-stroke-color-pickers input');
                    settings.fontStrokeColorPickers.forEach((color, i) => {
                        if(pickers[i]) pickers[i].value = color;
                    });
                }
                
                // Manually trigger events to update UI state
                document.getElementById('font-color-pickers').updateStates();
                document.getElementById('font-stroke-color-pickers').updateStates();
                document.querySelectorAll('input[name="font-color-mode"], input[name="font-stroke-color-mode"], input[name="text-opacity-mode"]').forEach(radio => {
                    if (radio.checked) {
                        radio.dispatchEvent(new Event('change'));
                    }
                });
            }

            function loadStateFromLocalStorage() {
                const savedSettings = localStorage.getItem(settingsKey);
                if (savedSettings) {
                    applySettings(JSON.parse(savedSettings));
                }
            }
            
            function addSaveStateListeners() {
                document.querySelectorAll('.save-state').forEach(el => {
                    el.removeEventListener('change', saveStateToLocalStorage); // Avoid duplicate listeners
                    el.removeEventListener('input', saveStateToLocalStorage);
                    el.addEventListener('change', saveStateToLocalStorage);
                    if (el.type === 'range' || el.type === 'number') {
                        el.addEventListener('input', saveStateToLocalStorage);
                    }
                });
            }
            
            function resetSettings(containerId) {
                const container = document.getElementById(containerId);
                const defaults = {
                    'canvas-width': 800, 'canvas-height': 600, 'bg-color': '#ffffff', 'bg-color-opacity': 0, 'bg-opacity': 1, 'bg-scale': 1,
                    'font-size-min': 16, 'font-size-max': 48, 'text-opacity': 1, 'vertical-ratio': 50, 'wrap-text': false, 'font-color-count': 1, 'font-stroke-color-count': 1
                };
                container.querySelectorAll('.save-state').forEach(el => {
                    const id = el.id;
                    if (defaults[id] !== undefined) {
                        if (el.type === 'checkbox') el.checked = defaults[id];
                        else el.value = defaults[id];
                        if (el.type === 'range' || el.type === 'number') el.dispatchEvent(new Event('input'));
                    }
                    // Reset radios
                    if(el.name === 'text-opacity-mode') if(el.value === 'specify') el.checked = true;
                    if(el.name === 'text-order') if(el.value === 'random') el.checked = true;
                    if(el.name === 'text-placement') if(el.value === 'soft-avoid') el.checked = true;
                    if(el.name === 'font-color-mode') if(el.value === 'random') el.checked = true;
                    if(el.name === 'font-bold-mode' || el.name === 'font-italic-mode' || el.name === 'font-shadow-mode' || el.name === 'font-stroke-mode') if(el.value === 'random') el.checked = true;
                    if(el.name === 'font-stroke-color-mode') if(el.value === 'random') el.checked = true;
                });
                saveStateToLocalStorage();
                generateAndRedraw();
            }

            resetFieldSettingsBtn.addEventListener('click', () => resetSettings('field-settings'));
            resetRandomSettingsBtn.addEventListener('click', () => resetSettings('random-settings'));
            fontSelectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('input[name="font-choice"]').forEach(cb => cb.checked = true);
                saveStateToLocalStorage();
            });
            fontDeselectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('input[name="font-choice"]').forEach(cb => cb.checked = false);
                saveStateToLocalStorage();
            });

            saveSettingsBtn.addEventListener('click', () => {
                const settings = {};
                document.querySelectorAll('.save-state').forEach(el => {
                    if (el.type === 'radio') {
                        if (el.checked) settings[el.name] = el.value;
                    } else if (el.type === 'checkbox') {
                        settings[el.id] = el.checked;
                    } else {
                        settings[el.id] = el.value;
                    }
                });
                settings.fontColorPickers = Array.from(document.querySelectorAll('#font-color-pickers input')).map(el => el.value);
                settings.fontStrokeColorPickers = Array.from(document.querySelectorAll('#font-stroke-color-pickers input')).map(el => el.value);
                
                const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'settings.json';
                a.click();
                URL.revokeObjectURL(url);
            });

            loadSettingsBtn.addEventListener('click', () => {
                settingsFileInput.click();
            });

            settingsFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const settings = JSON.parse(e.target.result);
                        applySettings(settings);
                        saveStateToLocalStorage();
                        generateAndRedraw();
                    } catch (err) {
                        console.error("Error parsing settings file:", err);
                        alert("設定ファイルの読み込みに失敗しました。");
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            });

            // 初期化
            populateFontList();
            setupColorPickers('font');
            setupColorPickers('font-stroke');
            loadStateFromLocalStorage();
            addSaveStateListeners();
            switchLanguage('ja');
            generateAndRedraw();
        });
    </script>
</body>
</html>
